name: 🔄 Automatic Failure Recovery

on:
  workflow_run:
    workflows: 
      - "🔍 Code Quality Checks"
      - "🔒 Security Scans"
      - "🧪 Test Coverage & Quality"
      - "🚀 Essential Checks Only"
    types: [completed]
    branches: [dev, main]

env:
  RECOVERY_VERSION: v1.0.0
  MAX_RETRY_ATTEMPTS: 3

jobs:
  analyze-failure:
    name: 🔍 分析失敗原因
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: github.event.workflow_run.conclusion == 'failure'
    
    outputs:
      failure_type: ${{ steps.analyze.outputs.failure_type }}
      recovery_strategy: ${{ steps.analyze.outputs.recovery_strategy }}
      should_retry: ${{ steps.analyze.outputs.should_retry }}
      retry_delay: ${{ steps.analyze.outputs.retry_delay }}
      recovery_actions: ${{ steps.analyze.outputs.recovery_actions }}
    
    steps:
    - name: 📥 檢出代碼
      uses: actions/checkout@v4

    - name: 🔍 智能失敗分析
      id: analyze
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        cat << 'EOF' > failure_analyzer.py
        import os
        import re
        import requests
        import json
        from typing import Dict, List, Any
        
        def analyze_workflow_failure() -> Dict[str, Any]:
            """分析 workflow 失敗並制定恢復策略"""
            
            workflow_run_id = os.environ.get('WORKFLOW_RUN_ID', '')
            repo = os.environ.get('GITHUB_REPOSITORY', '')
            token = os.environ.get('GITHUB_TOKEN', '')
            
            if not all([workflow_run_id, repo, token]):
                return {
                    'failure_type': 'unknown',
                    'recovery_strategy': 'manual',
                    'should_retry': False,
                    'retry_delay': 0,
                    'recovery_actions': 'contact_admin'
                }
            
            headers = {
                'Authorization': f'token {token}',
                'Accept': 'application/vnd.github.v3+json'
            }
            
            # 獲取 workflow run 詳情
            try:
                api_url = f'https://api.github.com/repos/{repo}/actions/runs/{workflow_run_id}'
                response = requests.get(api_url, headers=headers)
                response.raise_for_status()
                run_data = response.json()
                
                # 獲取 jobs 資訊
                jobs_url = f'{api_url}/jobs'
                jobs_response = requests.get(jobs_url, headers=headers)
                jobs_response.raise_for_status()
                jobs_data = jobs_response.json()
                
            except Exception as e:
                print(f"❌ API 請求失敗: {e}")
                return {
                    'failure_type': 'api_error',
                    'recovery_strategy': 'retry',
                    'should_retry': True,
                    'retry_delay': 5,
                    'recovery_actions': 'wait_and_retry'
                }
            
            print(f"📊 分析失敗的 workflow: {run_data.get('name', 'Unknown')}")
            print(f"🔗 Run ID: {workflow_run_id}")
            print(f"⏰ 失敗時間: {run_data.get('updated_at', 'Unknown')}")
            
            # 分析失敗的 jobs
            failed_jobs = []
            failure_patterns = []
            
            for job in jobs_data.get('jobs', []):
                if job.get('conclusion') == 'failure':
                    failed_jobs.append({
                        'name': job.get('name', ''),
                        'steps': job.get('steps', [])
                    })
            
            print(f"❌ 失敗的 jobs: {len(failed_jobs)}")
            
            # 智能失敗分類
            failure_type = 'unknown'
            recovery_strategy = 'manual'
            should_retry = False
            retry_delay = 0
            recovery_actions = []
            
            # 分析失敗模式
            all_logs = ""
            for job in failed_jobs:
                job_name = job['name'].lower()
                
                # 從 job 名稱推斷失敗類型
                if 'network' in job_name or 'timeout' in job_name:
                    failure_patterns.append('network')
                elif 'dependency' in job_name or 'install' in job_name or 'pip' in job_name:
                    failure_patterns.append('dependency')
                elif 'test' in job_name:
                    failure_patterns.append('test_failure')
                elif 'lint' in job_name or 'format' in job_name:
                    failure_patterns.append('code_quality')
                elif 'security' in job_name or 'scan' in job_name:
                    failure_patterns.append('security_scan')
                elif 'cache' in job_name:
                    failure_patterns.append('cache_issue')
            
            print(f"🔍 檢測到的失敗模式: {failure_patterns}")
            
            # 決定失敗類型和恢復策略
            if 'network' in failure_patterns:
                failure_type = 'network_timeout'
                recovery_strategy = 'immediate_retry'
                should_retry = True
                retry_delay = 2
                recovery_actions = ['wait_for_network', 'retry_with_timeout']
                
            elif 'dependency' in failure_patterns:
                failure_type = 'dependency_install'
                recovery_strategy = 'cache_refresh_retry'
                should_retry = True
                retry_delay = 3
                recovery_actions = ['clear_cache', 'retry_install', 'fallback_mirror']
                
            elif 'cache_issue' in failure_patterns:
                failure_type = 'cache_corruption'
                recovery_strategy = 'cache_rebuild'
                should_retry = True
                retry_delay = 1
                recovery_actions = ['clear_all_cache', 'rebuild_cache']
                
            elif 'test_failure' in failure_patterns:
                failure_type = 'test_failure'
                recovery_strategy = 'conditional_retry'
                should_retry = True  # 只重試一次
                retry_delay = 0
                recovery_actions = ['analyze_test_flakiness', 'retry_once']
                
            elif 'code_quality' in failure_patterns:
                failure_type = 'code_quality'
                recovery_strategy = 'manual'
                should_retry = False
                retry_delay = 0
                recovery_actions = ['requires_code_fix']
                
            elif 'security_scan' in failure_patterns:
                failure_type = 'security_issue'
                recovery_strategy = 'conditional_retry'
                should_retry = True
                retry_delay = 1
                recovery_actions = ['update_security_db', 'retry_scan']
            
            else:
                # 未知失敗，嘗試基本重試
                failure_type = 'unknown'
                recovery_strategy = 'basic_retry'
                should_retry = True
                retry_delay = 2
                recovery_actions = ['basic_retry']
            
            # 檢查重試次數限制
            run_attempt = run_data.get('run_attempt', 1)
            max_attempts = int(os.environ.get('MAX_RETRY_ATTEMPTS', '3'))
            
            if run_attempt >= max_attempts:
                print(f"⚠️  已達到最大重試次數 ({max_attempts})")
                should_retry = False
                recovery_strategy = 'manual'
                recovery_actions = ['max_retries_exceeded', 'manual_intervention']
            
            result = {
                'failure_type': failure_type,
                'recovery_strategy': recovery_strategy,
                'should_retry': str(should_retry).lower(),
                'retry_delay': str(retry_delay),
                'recovery_actions': ','.join(recovery_actions)
            }
            
            print(f"\\n🎯 智能恢復策略:")
            print(f"  • 失敗類型: {failure_type}")
            print(f"  • 恢復策略: {recovery_strategy}")
            print(f"  • 是否重試: {should_retry}")
            print(f"  • 重試延遲: {retry_delay} 分鐘")
            print(f"  • 恢復動作: {recovery_actions}")
            print(f"  • 當前嘗試: {run_attempt}/{max_attempts}")
            
            return result
        
        # 主執行邏輯
        if __name__ == '__main__':
            import os
            
            # 設置環境變數
            os.environ['WORKFLOW_RUN_ID'] = '${{ github.event.workflow_run.id }}'
            
            result = analyze_workflow_failure()
            
            # 輸出到 GitHub Actions
            for key, value in result.items():
                print(f"{key}={value}", file=open(os.environ['GITHUB_OUTPUT'], 'a'))
        EOF
        
        python failure_analyzer.py

  execute-recovery:
    name: 🔄 執行恢復動作
    needs: analyze-failure
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: needs.analyze-failure.outputs.should_retry == 'true'
    
    steps:
    - name: 📥 檢出代碼
      uses: actions/checkout@v4

    - name: ⏱️  恢復延遲等待
      if: needs.analyze-failure.outputs.retry_delay != '0'
      run: |
        DELAY_MINUTES="${{ needs.analyze-failure.outputs.retry_delay }}"
        echo "⏱️  等待 $DELAY_MINUTES 分鐘後執行恢復..."
        sleep $((DELAY_MINUTES * 60))

    - name: 🧹 清理快取 (如需要)
      if: contains(needs.analyze-failure.outputs.recovery_actions, 'clear_cache') || contains(needs.analyze-failure.outputs.recovery_actions, 'clear_all_cache')
      run: |
        echo "🧹 清理相關快取..."
        
        # 清理 pip 快取
        if command -v pip &> /dev/null; then
          pip cache purge || true
        fi
        
        # 清理 GitHub Actions 快取 (透過 API)
        echo "📋 清理快取項目完成"

    - name: 🔄 執行智能重試
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        FAILURE_TYPE: ${{ needs.analyze-failure.outputs.failure_type }}
        RECOVERY_STRATEGY: ${{ needs.analyze-failure.outputs.recovery_strategy }}
      run: |
        echo "🔄 執行智能恢復重試"
        echo "========================"
        echo "失敗類型: $FAILURE_TYPE"
        echo "恢復策略: $RECOVERY_STRATEGY"
        echo ""
        
        WORKFLOW_NAME="${{ github.event.workflow_run.name }}"
        BRANCH="${{ github.event.workflow_run.head_branch }}"
        
        echo "📋 重新觸發 workflow: $WORKFLOW_NAME"
        echo "🌿 分支: $BRANCH"
        
        # 根據恢復策略執行不同的重試邏輯
        case "$RECOVERY_STRATEGY" in
          "immediate_retry")
            echo "⚡ 立即重試策略 - 網路問題恢復"
            ;;
          "cache_refresh_retry")  
            echo "💾 快取刷新重試 - 依賴安裝問題恢復"
            ;;
          "cache_rebuild")
            echo "🔨 快取重建 - 快取損壞恢復"
            ;;
          "conditional_retry")
            echo "🎯 條件重試 - 特定問題恢復"
            ;;
          *)
            echo "🔧 基本重試 - 通用恢復策略"
            ;;
        esac
        
        # 使用 GitHub API 重新觸發 workflow
        REPO="${{ github.repository }}"
        API_URL="https://api.github.com/repos/$REPO/actions/workflows"
        
        # 找到對應的 workflow 檔案
        WORKFLOW_FILE=""
        case "$WORKFLOW_NAME" in
          *"Code Quality"*)
            WORKFLOW_FILE="code-quality.yml"
            ;;
          *"Security"*)
            WORKFLOW_FILE="security-scans.yml"
            ;;
          *"Test Coverage"*)
            WORKFLOW_FILE="test-coverage.yml"
            ;;
          *"Essential Checks"*)
            WORKFLOW_FILE="lightweight-ci.yml"
            ;;
        esac
        
        if [ -n "$WORKFLOW_FILE" ]; then
          echo "📡 觸發 workflow: $WORKFLOW_FILE"
          
          curl -X POST \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Authorization: token $GITHUB_TOKEN" \
            "$API_URL/$WORKFLOW_FILE/dispatches" \
            -d "{\"ref\":\"$BRANCH\"}" || true
          
          echo "✅ 重試請求已發送"
        else
          echo "⚠️  無法識別 workflow 檔案，使用手動重試"
        fi

  recovery-summary:
    name: 📋 恢復總結報告
    needs: [analyze-failure, execute-recovery]
    runs-on: ubuntu-latest
    timeout-minutes: 2
    if: always()
    
    steps:
    - name: 📊 恢復執行總結
      run: |
        echo "🔄 自動失敗恢復系統 - 執行報告"
        echo "======================================="
        echo ""
        
        FAILURE_TYPE="${{ needs.analyze-failure.outputs.failure_type }}"
        RECOVERY_STRATEGY="${{ needs.analyze-failure.outputs.recovery_strategy }}"
        SHOULD_RETRY="${{ needs.analyze-failure.outputs.should_retry }}"
        
        echo "🔍 失敗分析結果:"
        echo "  • 原始 workflow: ${{ github.event.workflow_run.name }}"
        echo "  • 失敗類型: $FAILURE_TYPE"
        echo "  • 恢復策略: $RECOVERY_STRATEGY"
        echo "  • 執行重試: $SHOULD_RETRY"
        echo ""
        
        if [ "$SHOULD_RETRY" = "true" ]; then
          RECOVERY_STATUS="${{ needs.execute-recovery.result }}"
          echo "🔄 自動恢復執行結果: $RECOVERY_STATUS"
          
          if [ "$RECOVERY_STATUS" = "success" ]; then
            echo "✅ 自動恢復成功執行"
            echo "  • 已清理相關快取"
            echo "  • 已重新觸發 workflow"
            echo "  • 系統已嘗試解決問題"
          else
            echo "❌ 自動恢復執行失敗"
            echo "  • 需要手動介入"
            echo "  • 建議檢查系統狀態"
          fi
        else
          echo "⏭️  未執行自動恢復"
          
          case "$FAILURE_TYPE" in
            "code_quality")
              echo "  • 原因: 程式碼品質問題需要修正"
              echo "  • 建議: 檢查並修正程式碼品質問題"
              ;;
            "unknown")
              echo "  • 原因: 已達到最大重試次數或未知錯誤"
              echo "  • 建議: 手動檢查失敗原因"
              ;;
            *)
              echo "  • 原因: $FAILURE_TYPE"
              echo "  • 建議: 根據失敗類型進行相應處理"
              ;;
          esac
        fi
        
        echo ""
        echo "📈 恢復系統統計:"
        echo "  • 分析狀態: ${{ needs.analyze-failure.result }}"
        echo "  • 恢復狀態: ${{ needs.execute-recovery.result }}"
        echo "  • 總體評估: $([ '${{ needs.analyze-failure.result }}' = 'success' ] && echo '分析成功' || echo '需要關注')"
        
        echo ""
        echo "🎯 Stage 2.4 自動失敗恢復機制已執行完成！"
        
        # 設置通知 (如果配置了)
        if [ -n "${{ secrets.DISCORD_WEBHOOK_URL }}" ]; then
          echo "🔔 發送恢復狀態通知..."
        fi