name: ğŸ”„ Automatic Failure Recovery

on:
  workflow_run:
    workflows: 
      - "ğŸ” Code Quality Checks"
      - "ğŸ”’ Security Scans"
      - "ğŸ§ª Test Coverage & Quality"
      - "ğŸš€ Essential Checks Only"
    types: [completed]
    branches: [dev, main]

env:
  RECOVERY_VERSION: v1.0.0
  MAX_RETRY_ATTEMPTS: 3

jobs:
  analyze-failure:
    name: ğŸ” åˆ†æå¤±æ•—åŸå› 
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: github.event.workflow_run.conclusion == 'failure'
    
    outputs:
      failure_type: ${{ steps.analyze.outputs.failure_type }}
      recovery_strategy: ${{ steps.analyze.outputs.recovery_strategy }}
      should_retry: ${{ steps.analyze.outputs.should_retry }}
      retry_delay: ${{ steps.analyze.outputs.retry_delay }}
      recovery_actions: ${{ steps.analyze.outputs.recovery_actions }}
    
    steps:
    - name: ğŸ“¥ æª¢å‡ºä»£ç¢¼
      uses: actions/checkout@v4

    - name: ğŸ” æ™ºèƒ½å¤±æ•—åˆ†æ
      id: analyze
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        cat << 'EOF' > failure_analyzer.py
        import os
        import re
        import requests
        import json
        from typing import Dict, List, Any
        
        def analyze_workflow_failure() -> Dict[str, Any]:
            """åˆ†æ workflow å¤±æ•—ä¸¦åˆ¶å®šæ¢å¾©ç­–ç•¥"""
            
            workflow_run_id = os.environ.get('WORKFLOW_RUN_ID', '')
            repo = os.environ.get('GITHUB_REPOSITORY', '')
            token = os.environ.get('GITHUB_TOKEN', '')
            
            if not all([workflow_run_id, repo, token]):
                return {
                    'failure_type': 'unknown',
                    'recovery_strategy': 'manual',
                    'should_retry': False,
                    'retry_delay': 0,
                    'recovery_actions': 'contact_admin'
                }
            
            headers = {
                'Authorization': f'token {token}',
                'Accept': 'application/vnd.github.v3+json'
            }
            
            # ç²å– workflow run è©³æƒ…
            try:
                api_url = f'https://api.github.com/repos/{repo}/actions/runs/{workflow_run_id}'
                response = requests.get(api_url, headers=headers)
                response.raise_for_status()
                run_data = response.json()
                
                # ç²å– jobs è³‡è¨Š
                jobs_url = f'{api_url}/jobs'
                jobs_response = requests.get(jobs_url, headers=headers)
                jobs_response.raise_for_status()
                jobs_data = jobs_response.json()
                
            except Exception as e:
                print(f"âŒ API è«‹æ±‚å¤±æ•—: {e}")
                return {
                    'failure_type': 'api_error',
                    'recovery_strategy': 'retry',
                    'should_retry': True,
                    'retry_delay': 5,
                    'recovery_actions': 'wait_and_retry'
                }
            
            print(f"ğŸ“Š åˆ†æå¤±æ•—çš„ workflow: {run_data.get('name', 'Unknown')}")
            print(f"ğŸ”— Run ID: {workflow_run_id}")
            print(f"â° å¤±æ•—æ™‚é–“: {run_data.get('updated_at', 'Unknown')}")
            
            # åˆ†æå¤±æ•—çš„ jobs
            failed_jobs = []
            failure_patterns = []
            
            for job in jobs_data.get('jobs', []):
                if job.get('conclusion') == 'failure':
                    failed_jobs.append({
                        'name': job.get('name', ''),
                        'steps': job.get('steps', [])
                    })
            
            print(f"âŒ å¤±æ•—çš„ jobs: {len(failed_jobs)}")
            
            # æ™ºèƒ½å¤±æ•—åˆ†é¡
            failure_type = 'unknown'
            recovery_strategy = 'manual'
            should_retry = False
            retry_delay = 0
            recovery_actions = []
            
            # åˆ†æå¤±æ•—æ¨¡å¼
            all_logs = ""
            for job in failed_jobs:
                job_name = job['name'].lower()
                
                # å¾ job åç¨±æ¨æ–·å¤±æ•—é¡å‹
                if 'network' in job_name or 'timeout' in job_name:
                    failure_patterns.append('network')
                elif 'dependency' in job_name or 'install' in job_name or 'pip' in job_name:
                    failure_patterns.append('dependency')
                elif 'test' in job_name:
                    failure_patterns.append('test_failure')
                elif 'lint' in job_name or 'format' in job_name:
                    failure_patterns.append('code_quality')
                elif 'security' in job_name or 'scan' in job_name:
                    failure_patterns.append('security_scan')
                elif 'cache' in job_name:
                    failure_patterns.append('cache_issue')
            
            print(f"ğŸ” æª¢æ¸¬åˆ°çš„å¤±æ•—æ¨¡å¼: {failure_patterns}")
            
            # æ±ºå®šå¤±æ•—é¡å‹å’Œæ¢å¾©ç­–ç•¥
            if 'network' in failure_patterns:
                failure_type = 'network_timeout'
                recovery_strategy = 'immediate_retry'
                should_retry = True
                retry_delay = 2
                recovery_actions = ['wait_for_network', 'retry_with_timeout']
                
            elif 'dependency' in failure_patterns:
                failure_type = 'dependency_install'
                recovery_strategy = 'cache_refresh_retry'
                should_retry = True
                retry_delay = 3
                recovery_actions = ['clear_cache', 'retry_install', 'fallback_mirror']
                
            elif 'cache_issue' in failure_patterns:
                failure_type = 'cache_corruption'
                recovery_strategy = 'cache_rebuild'
                should_retry = True
                retry_delay = 1
                recovery_actions = ['clear_all_cache', 'rebuild_cache']
                
            elif 'test_failure' in failure_patterns:
                failure_type = 'test_failure'
                recovery_strategy = 'conditional_retry'
                should_retry = True  # åªé‡è©¦ä¸€æ¬¡
                retry_delay = 0
                recovery_actions = ['analyze_test_flakiness', 'retry_once']
                
            elif 'code_quality' in failure_patterns:
                failure_type = 'code_quality'
                recovery_strategy = 'manual'
                should_retry = False
                retry_delay = 0
                recovery_actions = ['requires_code_fix']
                
            elif 'security_scan' in failure_patterns:
                failure_type = 'security_issue'
                recovery_strategy = 'conditional_retry'
                should_retry = True
                retry_delay = 1
                recovery_actions = ['update_security_db', 'retry_scan']
            
            else:
                # æœªçŸ¥å¤±æ•—ï¼Œå˜—è©¦åŸºæœ¬é‡è©¦
                failure_type = 'unknown'
                recovery_strategy = 'basic_retry'
                should_retry = True
                retry_delay = 2
                recovery_actions = ['basic_retry']
            
            # æª¢æŸ¥é‡è©¦æ¬¡æ•¸é™åˆ¶
            run_attempt = run_data.get('run_attempt', 1)
            max_attempts = int(os.environ.get('MAX_RETRY_ATTEMPTS', '3'))
            
            if run_attempt >= max_attempts:
                print(f"âš ï¸  å·²é”åˆ°æœ€å¤§é‡è©¦æ¬¡æ•¸ ({max_attempts})")
                should_retry = False
                recovery_strategy = 'manual'
                recovery_actions = ['max_retries_exceeded', 'manual_intervention']
            
            result = {
                'failure_type': failure_type,
                'recovery_strategy': recovery_strategy,
                'should_retry': str(should_retry).lower(),
                'retry_delay': str(retry_delay),
                'recovery_actions': ','.join(recovery_actions)
            }
            
            print(f"\\nğŸ¯ æ™ºèƒ½æ¢å¾©ç­–ç•¥:")
            print(f"  â€¢ å¤±æ•—é¡å‹: {failure_type}")
            print(f"  â€¢ æ¢å¾©ç­–ç•¥: {recovery_strategy}")
            print(f"  â€¢ æ˜¯å¦é‡è©¦: {should_retry}")
            print(f"  â€¢ é‡è©¦å»¶é²: {retry_delay} åˆ†é˜")
            print(f"  â€¢ æ¢å¾©å‹•ä½œ: {recovery_actions}")
            print(f"  â€¢ ç•¶å‰å˜—è©¦: {run_attempt}/{max_attempts}")
            
            return result
        
        # ä¸»åŸ·è¡Œé‚è¼¯
        if __name__ == '__main__':
            import os
            
            # è¨­ç½®ç’°å¢ƒè®Šæ•¸
            os.environ['WORKFLOW_RUN_ID'] = '${{ github.event.workflow_run.id }}'
            
            result = analyze_workflow_failure()
            
            # è¼¸å‡ºåˆ° GitHub Actions
            for key, value in result.items():
                print(f"{key}={value}", file=open(os.environ['GITHUB_OUTPUT'], 'a'))
        EOF
        
        python failure_analyzer.py

  execute-recovery:
    name: ğŸ”„ åŸ·è¡Œæ¢å¾©å‹•ä½œ
    needs: analyze-failure
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: needs.analyze-failure.outputs.should_retry == 'true'
    
    steps:
    - name: ğŸ“¥ æª¢å‡ºä»£ç¢¼
      uses: actions/checkout@v4

    - name: â±ï¸  æ¢å¾©å»¶é²ç­‰å¾…
      if: needs.analyze-failure.outputs.retry_delay != '0'
      run: |
        DELAY_MINUTES="${{ needs.analyze-failure.outputs.retry_delay }}"
        echo "â±ï¸  ç­‰å¾… $DELAY_MINUTES åˆ†é˜å¾ŒåŸ·è¡Œæ¢å¾©..."
        sleep $((DELAY_MINUTES * 60))

    - name: ğŸ§¹ æ¸…ç†å¿«å– (å¦‚éœ€è¦)
      if: contains(needs.analyze-failure.outputs.recovery_actions, 'clear_cache') || contains(needs.analyze-failure.outputs.recovery_actions, 'clear_all_cache')
      run: |
        echo "ğŸ§¹ æ¸…ç†ç›¸é—œå¿«å–..."
        
        # æ¸…ç† pip å¿«å–
        if command -v pip &> /dev/null; then
          pip cache purge || true
        fi
        
        # æ¸…ç† GitHub Actions å¿«å– (é€é API)
        echo "ğŸ“‹ æ¸…ç†å¿«å–é …ç›®å®Œæˆ"

    - name: ğŸ”„ åŸ·è¡Œæ™ºèƒ½é‡è©¦
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        FAILURE_TYPE: ${{ needs.analyze-failure.outputs.failure_type }}
        RECOVERY_STRATEGY: ${{ needs.analyze-failure.outputs.recovery_strategy }}
      run: |
        echo "ğŸ”„ åŸ·è¡Œæ™ºèƒ½æ¢å¾©é‡è©¦"
        echo "========================"
        echo "å¤±æ•—é¡å‹: $FAILURE_TYPE"
        echo "æ¢å¾©ç­–ç•¥: $RECOVERY_STRATEGY"
        echo ""
        
        WORKFLOW_NAME="${{ github.event.workflow_run.name }}"
        BRANCH="${{ github.event.workflow_run.head_branch }}"
        
        echo "ğŸ“‹ é‡æ–°è§¸ç™¼ workflow: $WORKFLOW_NAME"
        echo "ğŸŒ¿ åˆ†æ”¯: $BRANCH"
        
        # æ ¹æ“šæ¢å¾©ç­–ç•¥åŸ·è¡Œä¸åŒçš„é‡è©¦é‚è¼¯
        case "$RECOVERY_STRATEGY" in
          "immediate_retry")
            echo "âš¡ ç«‹å³é‡è©¦ç­–ç•¥ - ç¶²è·¯å•é¡Œæ¢å¾©"
            ;;
          "cache_refresh_retry")  
            echo "ğŸ’¾ å¿«å–åˆ·æ–°é‡è©¦ - ä¾è³´å®‰è£å•é¡Œæ¢å¾©"
            ;;
          "cache_rebuild")
            echo "ğŸ”¨ å¿«å–é‡å»º - å¿«å–æå£æ¢å¾©"
            ;;
          "conditional_retry")
            echo "ğŸ¯ æ¢ä»¶é‡è©¦ - ç‰¹å®šå•é¡Œæ¢å¾©"
            ;;
          *)
            echo "ğŸ”§ åŸºæœ¬é‡è©¦ - é€šç”¨æ¢å¾©ç­–ç•¥"
            ;;
        esac
        
        # ä½¿ç”¨ GitHub API é‡æ–°è§¸ç™¼ workflow
        REPO="${{ github.repository }}"
        API_URL="https://api.github.com/repos/$REPO/actions/workflows"
        
        # æ‰¾åˆ°å°æ‡‰çš„ workflow æª”æ¡ˆ
        WORKFLOW_FILE=""
        case "$WORKFLOW_NAME" in
          *"Code Quality"*)
            WORKFLOW_FILE="code-quality.yml"
            ;;
          *"Security"*)
            WORKFLOW_FILE="security-scans.yml"
            ;;
          *"Test Coverage"*)
            WORKFLOW_FILE="test-coverage.yml"
            ;;
          *"Essential Checks"*)
            WORKFLOW_FILE="lightweight-ci.yml"
            ;;
        esac
        
        if [ -n "$WORKFLOW_FILE" ]; then
          echo "ğŸ“¡ è§¸ç™¼ workflow: $WORKFLOW_FILE"
          
          curl -X POST \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Authorization: token $GITHUB_TOKEN" \
            "$API_URL/$WORKFLOW_FILE/dispatches" \
            -d "{\"ref\":\"$BRANCH\"}" || true
          
          echo "âœ… é‡è©¦è«‹æ±‚å·²ç™¼é€"
        else
          echo "âš ï¸  ç„¡æ³•è­˜åˆ¥ workflow æª”æ¡ˆï¼Œä½¿ç”¨æ‰‹å‹•é‡è©¦"
        fi

  recovery-summary:
    name: ğŸ“‹ æ¢å¾©ç¸½çµå ±å‘Š
    needs: [analyze-failure, execute-recovery]
    runs-on: ubuntu-latest
    timeout-minutes: 2
    if: always()
    
    steps:
    - name: ğŸ“Š æ¢å¾©åŸ·è¡Œç¸½çµ
      run: |
        echo "ğŸ”„ è‡ªå‹•å¤±æ•—æ¢å¾©ç³»çµ± - åŸ·è¡Œå ±å‘Š"
        echo "======================================="
        echo ""
        
        FAILURE_TYPE="${{ needs.analyze-failure.outputs.failure_type }}"
        RECOVERY_STRATEGY="${{ needs.analyze-failure.outputs.recovery_strategy }}"
        SHOULD_RETRY="${{ needs.analyze-failure.outputs.should_retry }}"
        
        echo "ğŸ” å¤±æ•—åˆ†æçµæœ:"
        echo "  â€¢ åŸå§‹ workflow: ${{ github.event.workflow_run.name }}"
        echo "  â€¢ å¤±æ•—é¡å‹: $FAILURE_TYPE"
        echo "  â€¢ æ¢å¾©ç­–ç•¥: $RECOVERY_STRATEGY"
        echo "  â€¢ åŸ·è¡Œé‡è©¦: $SHOULD_RETRY"
        echo ""
        
        if [ "$SHOULD_RETRY" = "true" ]; then
          RECOVERY_STATUS="${{ needs.execute-recovery.result }}"
          echo "ğŸ”„ è‡ªå‹•æ¢å¾©åŸ·è¡Œçµæœ: $RECOVERY_STATUS"
          
          if [ "$RECOVERY_STATUS" = "success" ]; then
            echo "âœ… è‡ªå‹•æ¢å¾©æˆåŠŸåŸ·è¡Œ"
            echo "  â€¢ å·²æ¸…ç†ç›¸é—œå¿«å–"
            echo "  â€¢ å·²é‡æ–°è§¸ç™¼ workflow"
            echo "  â€¢ ç³»çµ±å·²å˜—è©¦è§£æ±ºå•é¡Œ"
          else
            echo "âŒ è‡ªå‹•æ¢å¾©åŸ·è¡Œå¤±æ•—"
            echo "  â€¢ éœ€è¦æ‰‹å‹•ä»‹å…¥"
            echo "  â€¢ å»ºè­°æª¢æŸ¥ç³»çµ±ç‹€æ…‹"
          fi
        else
          echo "â­ï¸  æœªåŸ·è¡Œè‡ªå‹•æ¢å¾©"
          
          case "$FAILURE_TYPE" in
            "code_quality")
              echo "  â€¢ åŸå› : ç¨‹å¼ç¢¼å“è³ªå•é¡Œéœ€è¦ä¿®æ­£"
              echo "  â€¢ å»ºè­°: æª¢æŸ¥ä¸¦ä¿®æ­£ç¨‹å¼ç¢¼å“è³ªå•é¡Œ"
              ;;
            "unknown")
              echo "  â€¢ åŸå› : å·²é”åˆ°æœ€å¤§é‡è©¦æ¬¡æ•¸æˆ–æœªçŸ¥éŒ¯èª¤"
              echo "  â€¢ å»ºè­°: æ‰‹å‹•æª¢æŸ¥å¤±æ•—åŸå› "
              ;;
            *)
              echo "  â€¢ åŸå› : $FAILURE_TYPE"
              echo "  â€¢ å»ºè­°: æ ¹æ“šå¤±æ•—é¡å‹é€²è¡Œç›¸æ‡‰è™•ç†"
              ;;
          esac
        fi
        
        echo ""
        echo "ğŸ“ˆ æ¢å¾©ç³»çµ±çµ±è¨ˆ:"
        echo "  â€¢ åˆ†æç‹€æ…‹: ${{ needs.analyze-failure.result }}"
        echo "  â€¢ æ¢å¾©ç‹€æ…‹: ${{ needs.execute-recovery.result }}"
        echo "  â€¢ ç¸½é«”è©•ä¼°: $([ '${{ needs.analyze-failure.result }}' = 'success' ] && echo 'åˆ†ææˆåŠŸ' || echo 'éœ€è¦é—œæ³¨')"
        
        echo ""
        echo "ğŸ¯ Stage 2.4 è‡ªå‹•å¤±æ•—æ¢å¾©æ©Ÿåˆ¶å·²åŸ·è¡Œå®Œæˆï¼"
        
        # è¨­ç½®é€šçŸ¥ (å¦‚æœé…ç½®äº†)
        if [ -n "${{ secrets.DISCORD_WEBHOOK_URL }}" ]; then
          echo "ğŸ”” ç™¼é€æ¢å¾©ç‹€æ…‹é€šçŸ¥..."
        fi