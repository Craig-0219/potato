name: ðŸ¤– Auto Merge

on:
  pull_request:
    types: [labeled, unlabeled, synchronize, ready_for_review]
  pull_request_review:
    types: [submitted]
  workflow_run:
    workflows: ["ðŸš€ CI Pipeline"]
    types: [completed]

permissions:
  contents: write
  pull-requests: write
  checks: read

jobs:
  auto-merge:
    name: ðŸš€ è‡ªå‹•åˆä½µæª¢æŸ¥
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success'
    
    steps:
    - name: ðŸ” ç²å– PR ä¿¡æ¯
      id: pr-info
      uses: actions/github-script@v6
      with:
        script: |
          let prData;
          
          if (context.eventName === 'pull_request') {
            prData = context.payload.pull_request;
          } else if (context.eventName === 'pull_request_review') {
            prData = context.payload.pull_request;
          } else if (context.eventName === 'workflow_run') {
            // æŸ¥æ‰¾é—œè¯çš„ PR
            const prs = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              head: `${context.repo.owner}:${context.payload.workflow_run.head_branch}`
            });
            
            if (prs.data.length === 0) {
              console.log('æœªæ‰¾åˆ°é—œè¯çš„ PR');
              return { shouldSkip: true };
            }
            
            prData = prs.data[0];
          }
          
          return {
            number: prData.number,
            title: prData.title,
            author: prData.user.login,
            baseBranch: prData.base.ref,
            headBranch: prData.head.ref,
            draft: prData.draft,
            mergeable: prData.mergeable,
            shouldSkip: false
          };
    
    - name: ðŸ·ï¸ æª¢æŸ¥è‡ªå‹•åˆä½µæ¢ä»¶
      id: check-conditions
      if: fromJSON(steps.pr-info.outputs.result).shouldSkip != true
      uses: actions/github-script@v6
      with:
        script: |
          const prInfo = ${{ steps.pr-info.outputs.result }};
          
          // ç²å– PR æ¨™ç±¤
          const { data: labels } = await github.rest.issues.listLabelsOnIssue({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: prInfo.number
          });
          
          const labelNames = labels.map(label => label.name);
          console.log(`PR æ¨™ç±¤: ${labelNames.join(', ')}`);
          
          // æª¢æŸ¥è‡ªå‹•åˆä½µæ¨™ç±¤
          const hasAutoMergeLabel = labelNames.some(label => 
            ['auto-merge', 'ðŸ¤– auto-merge', 'ready-to-merge'].includes(label)
          );
          
          // æª¢æŸ¥é˜»æ“‹æ¨™ç±¤
          const hasBlockingLabel = labelNames.some(label => 
            ['do-not-merge', 'âŒ do-not-merge', 'work-in-progress', 'needs-review'].includes(label)
          );
          
          // æª¢æŸ¥è‰ç¨¿ç‹€æ…‹
          if (prInfo.draft) {
            return { canMerge: false, reason: 'PR ä»ç‚ºè‰ç¨¿ç‹€æ…‹' };
          }
          
          if (!hasAutoMergeLabel) {
            return { canMerge: false, reason: 'æœªè¨­ç½®è‡ªå‹•åˆä½µæ¨™ç±¤' };
          }
          
          if (hasBlockingLabel) {
            return { canMerge: false, reason: 'å­˜åœ¨é˜»æ“‹æ¨™ç±¤' };
          }
          
          // æª¢æŸ¥å¯©æŸ¥è¦æ±‚ (ç°¡åŒ–é‚è¼¯)
          const { data: reviews } = await github.rest.pulls.listReviews({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: prInfo.number
          });
          
          const latestReviews = {};
          reviews.forEach(review => {
            latestReviews[review.user.login] = review.state;
          });
          
          const approvals = Object.values(latestReviews).filter(state => state === 'APPROVED').length;
          const rejections = Object.values(latestReviews).filter(state => state === 'REQUEST_CHANGES').length;
          
          // æ ¹æ“šç›®æ¨™åˆ†æ”¯æ±ºå®šå¯©æŸ¥è¦æ±‚
          let requiredApprovals = 0;
          if (prInfo.baseBranch === 'main') {
            requiredApprovals = 1;  // main åˆ†æ”¯éœ€è¦ 1 å€‹æ‰¹å‡†
          }
          
          if (rejections > 0) {
            return { canMerge: false, reason: `å­˜åœ¨ ${rejections} å€‹æ‹’çµ•å¯©æŸ¥` };
          }
          
          if (approvals < requiredApprovals) {
            return { canMerge: false, reason: `å¯©æŸ¥ä¸è¶³ (éœ€è¦: ${requiredApprovals}, ç•¶å‰: ${approvals})` };
          }
          
          return { 
            canMerge: true, 
            reason: 'ç¬¦åˆè‡ªå‹•åˆä½µæ¢ä»¶',
            approvals: approvals,
            requiredApprovals: requiredApprovals
          };
    
    - name: ðŸš€ åŸ·è¡Œè‡ªå‹•åˆä½µ
      if: fromJSON(steps.check-conditions.outputs.result).canMerge == true
      uses: actions/github-script@v6
      with:
        script: |
          const prInfo = ${{ steps.pr-info.outputs.result }};
          
          try {
            // å•Ÿç”¨è‡ªå‹•åˆä½µ (ä½¿ç”¨ GitHub åŽŸç”ŸåŠŸèƒ½)
            await github.rest.pulls.enableAutoMerge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prInfo.number,
              merge_method: prInfo.baseBranch === 'main' ? 'squash' : 'merge'
            });
            
            console.log(`âœ… å·²å•Ÿç”¨ PR #${prInfo.number} çš„è‡ªå‹•åˆä½µ`);
            
            // æ·»åŠ æˆåŠŸè©•è«–
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prInfo.number,
              body: `ðŸ¤– **è‡ªå‹•åˆä½µå·²å•Ÿç”¨**
              
âœ… æ‰€æœ‰æª¢æŸ¥é€šéŽå¾Œå°‡è‡ªå‹•åˆä½µåˆ° \`${prInfo.baseBranch}\` åˆ†æ”¯
ðŸ”„ åˆä½µæ–¹å¼: ${prInfo.baseBranch === 'main' ? 'Squash' : 'Merge'}
              
æ„Ÿè¬ @${prInfo.author} çš„è²¢ç»ï¼ ðŸš€`
            });
            
          } catch (error) {
            console.error('è‡ªå‹•åˆä½µè¨­ç½®å¤±æ•—:', error);
            
            // æ·»åŠ å¤±æ•—è©•è«–
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prInfo.number,
              body: `âŒ **è‡ªå‹•åˆä½µè¨­ç½®å¤±æ•—**
              
éŒ¯èª¤: ${error.message}
              
è«‹æª¢æŸ¥ PR ç‹€æ…‹æˆ–æ‰‹å‹•è™•ç†åˆä½µã€‚`
            });
            
            throw error;
          }
    
    - name: ðŸ“‹ çµæžœç¸½çµ
      if: always() && fromJSON(steps.pr-info.outputs.result).shouldSkip != true
      run: |
        echo "ðŸ¤– è‡ªå‹•åˆä½µæª¢æŸ¥å®Œæˆ"
        echo ""
        
        CONDITIONS='${{ steps.check-conditions.outputs.result }}'
        
        if [[ "$CONDITIONS" == *'"canMerge":true'* ]]; then
          echo "âœ… è‡ªå‹•åˆä½µæ¢ä»¶: ç¬¦åˆ"
          echo "ðŸš€ ç‹€æ…‹: å·²å•Ÿç”¨è‡ªå‹•åˆä½µ"
        else
          echo "âŒ è‡ªå‹•åˆä½µæ¢ä»¶: ä¸ç¬¦åˆ"
          REASON=$(echo "$CONDITIONS" | jq -r '.reason // "æœªçŸ¥åŽŸå› "')
          echo "ðŸ“ åŽŸå› : $REASON"
          echo ""
          echo "ðŸ’¡ å¦‚éœ€å•Ÿç”¨è‡ªå‹•åˆä½µ:"
          echo "1. æ·»åŠ  'auto-merge' æ¨™ç±¤"
          echo "2. ç¢ºä¿æ‰€æœ‰ CI æª¢æŸ¥é€šéŽ"
          echo "3. ç²å¾—å¿…è¦çš„ä»£ç¢¼å¯©æŸ¥æ‰¹å‡†"
          echo "4. ç§»é™¤ä»»ä½•é˜»æ“‹æ¨™ç±¤ (do-not-merge ç­‰)"
        fi