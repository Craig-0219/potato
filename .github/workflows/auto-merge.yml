name: ğŸ¤– Auto Merge

on:
  pull_request:
    types: [labeled, unlabeled, synchronize]
  pull_request_review:
    types: [submitted]
  check_suite:
    types: [completed]
  status: {}

permissions:
  contents: write
  pull-requests: write
  checks: read

jobs:
  auto-merge:
    name: ğŸš€ è‡ªå‹•åˆä½µæª¢æŸ¥
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    if: github.event_name == 'pull_request' || github.event_name == 'pull_request_review' || github.event_name == 'check_suite' || github.event_name == 'status'
    
    steps:
    - name: ğŸ“¥ æª¢å‡ºç¨‹å¼ç¢¼
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: ğŸ” ç²å– PR è³‡è¨Š
      id: pr-info
      uses: actions/github-script@v6
      with:
        script: |
          let prNumber;
          let prData;
          
          if (context.eventName === 'pull_request') {
            prNumber = context.payload.number;
            prData = context.payload.pull_request;
          } else if (context.eventName === 'pull_request_review') {
            prNumber = context.payload.pull_request.number;
            prData = context.payload.pull_request;
          } else {
            // å°æ–¼ check_suite æˆ– status äº‹ä»¶ï¼Œæ‰¾åˆ°ç›¸é—œçš„ PR
            const prs = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open'
            });
            
            const associatedPR = prs.data.find(pr => pr.head.sha === context.payload.sha);
            if (!associatedPR) {
              console.log('æ²’æœ‰æ‰¾åˆ°ç›¸é—œçš„ PR');
              return { shouldSkip: true };
            }
            
            prNumber = associatedPR.number;
            prData = associatedPR;
          }
          
          return {
            number: prNumber,
            title: prData.title,
            author: prData.user.login,
            baseBranch: prData.base.ref,
            headBranch: prData.head.ref,
            draft: prData.draft,
            mergeable: prData.mergeable,
            shouldSkip: false
          };
    
    - name: ğŸ·ï¸ æª¢æŸ¥è‡ªå‹•åˆä½µæ¨™ç±¤
      id: check-labels
      uses: actions/github-script@v6
      with:
        script: |
          const prInfo = ${{ steps.pr-info.outputs.result }};
          
          if (prInfo.shouldSkip) {
            return { canAutoMerge: false, reason: 'No associated PR found' };
          }
          
          // ç²å– PR æ¨™ç±¤
          const { data: labels } = await github.rest.issues.listLabelsOnIssue({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: prInfo.number
          });
          
          const labelNames = labels.map(label => label.name);
          console.log(`PR æ¨™ç±¤: ${labelNames.join(', ')}`);
          
          // æª¢æŸ¥æ˜¯å¦æœ‰è‡ªå‹•åˆä½µæ¨™ç±¤
          const autoMergeLabels = ['auto-merge', 'ğŸ¤– auto-merge', 'ready-to-merge'];
          const hasAutoMergeLabel = autoMergeLabels.some(label => labelNames.includes(label));
          
          // æª¢æŸ¥æ˜¯å¦æœ‰é˜»æ“‹æ¨™ç±¤
          const blockingLabels = ['do-not-merge', 'âŒ do-not-merge', 'work-in-progress', 'needs-review'];
          const hasBlockingLabel = blockingLabels.some(label => labelNames.includes(label));
          
          if (!hasAutoMergeLabel) {
            return { canAutoMerge: false, reason: 'No auto-merge label found' };
          }
          
          if (hasBlockingLabel) {
            return { canAutoMerge: false, reason: 'Blocking label present' };
          }
          
          // æª¢æŸ¥æ˜¯å¦ç‚ºè‰ç¨¿
          if (prInfo.draft) {
            return { canAutoMerge: false, reason: 'PR is still a draft' };
          }
          
          return { canAutoMerge: true, reason: 'Auto-merge label found and no blocking conditions' };
    
    - name: âœ… æª¢æŸ¥å¿…è¦çš„ç‹€æ…‹æª¢æŸ¥
      id: check-status
      uses: actions/github-script@v6
      if: fromJSON(steps.check-labels.outputs.result).canAutoMerge
      with:
        script: |
          const prInfo = ${{ steps.pr-info.outputs.result }};
          
          // ç²å–åˆ†æ”¯ä¿è­·è¦å‰‡
          let requiredChecks = [];
          try {
            const { data: branch } = await github.rest.repos.getBranch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              branch: prInfo.baseBranch
            });
            
            if (branch.protection && branch.protection.required_status_checks) {
              requiredChecks = branch.protection.required_status_checks.contexts || [];
            }
          } catch (error) {
            console.log('ç„¡æ³•ç²å–åˆ†æ”¯ä¿è­·è¦å‰‡ï¼Œä½¿ç”¨é è¨­æª¢æŸ¥');
            
            // é è¨­å¿…è¦æª¢æŸ¥ï¼ˆæ ¹æ“šç›®æ¨™åˆ†æ”¯ï¼‰
            if (prInfo.baseBranch === 'main') {
              requiredChecks = [
                'code-quality',
                'security-scans', 
                'test-coverage',
                'build-validation'
              ];
            } else if (prInfo.baseBranch === 'develop') {
              requiredChecks = [
                'code-quality',
                'test-coverage'
              ];
            }
          }
          
          console.log(`å¿…è¦æª¢æŸ¥: ${requiredChecks.join(', ')}`);
          
          if (requiredChecks.length === 0) {
            return { allChecksPassed: true, failedChecks: [] };
          }
          
          // ç²å– PR çš„æª¢æŸ¥ç‹€æ…‹
          const { data: checks } = await github.rest.checks.listForRef({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: prInfo.headBranch
          });
          
          const checkMap = {};
          checks.check_runs.forEach(check => {
            checkMap[check.name] = check.conclusion;
          });
          
          // æª¢æŸ¥ç‹€æ…‹
          const { data: statuses } = await github.rest.repos.listCommitStatusesForRef({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: prInfo.headBranch
          });
          
          statuses.forEach(status => {
            if (!checkMap[status.context]) {
              checkMap[status.context] = status.state === 'success' ? 'success' : 'failure';
            }
          });
          
          // æª¢æŸ¥æ‰€æœ‰å¿…è¦æª¢æŸ¥æ˜¯å¦é€šé
          const failedChecks = [];
          const pendingChecks = [];
          
          for (const check of requiredChecks) {
            const status = checkMap[check];
            if (status === 'failure' || status === 'cancelled' || status === 'timed_out') {
              failedChecks.push(check);
            } else if (!status || status === 'pending' || status === 'queued' || status === 'in_progress') {
              pendingChecks.push(check);
            }
          }
          
          console.log(`å¤±æ•—çš„æª¢æŸ¥: ${failedChecks.join(', ')}`);
          console.log(`å¾…è™•ç†çš„æª¢æŸ¥: ${pendingChecks.join(', ')}`);
          
          return {
            allChecksPassed: failedChecks.length === 0 && pendingChecks.length === 0,
            failedChecks,
            pendingChecks
          };
    
    - name: ğŸ‘¥ æª¢æŸ¥å¯©æŸ¥è¦æ±‚
      id: check-reviews
      uses: actions/github-script@v6
      if: fromJSON(steps.check-labels.outputs.result).canAutoMerge && fromJSON(steps.check-status.outputs.result).allChecksPassed
      with:
        script: |
          const prInfo = ${{ steps.pr-info.outputs.result }};
          
          // ç²å– PR å¯©æŸ¥
          const { data: reviews } = await github.rest.pulls.listReviews({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: prInfo.number
          });
          
          // æ ¹æ“šç›®æ¨™åˆ†æ”¯æ±ºå®šå¯©æŸ¥è¦æ±‚
          let requiredApprovals = 0;
          if (prInfo.baseBranch === 'main') {
            requiredApprovals = 2;  // main åˆ†æ”¯éœ€è¦ 2 å€‹æ‰¹å‡†
          } else if (prInfo.baseBranch === 'develop') {
            requiredApprovals = 1;  // develop åˆ†æ”¯éœ€è¦ 1 å€‹æ‰¹å‡†
          }
          
          // çµ±è¨ˆå¯©æŸ¥çµæœ
          const latestReviews = {};
          reviews.forEach(review => {
            latestReviews[review.user.login] = review.state;
          });
          
          const approvals = Object.values(latestReviews).filter(state => state === 'APPROVED').length;
          const rejections = Object.values(latestReviews).filter(state => state === 'REQUEST_CHANGES').length;
          
          console.log(`éœ€è¦æ‰¹å‡†æ•¸: ${requiredApprovals}, ç•¶å‰æ‰¹å‡†æ•¸: ${approvals}, æ‹’çµ•æ•¸: ${rejections}`);
          
          return {
            hasEnoughApprovals: approvals >= requiredApprovals,
            hasRejections: rejections > 0,
            approvals,
            rejections,
            requiredApprovals
          };
    
    - name: ğŸš€ åŸ·è¡Œè‡ªå‹•åˆä½µ
      id: merge
      uses: actions/github-script@v6
      if: |
        fromJSON(steps.check-labels.outputs.result).canAutoMerge && 
        fromJSON(steps.check-status.outputs.result).allChecksPassed && 
        fromJSON(steps.check-reviews.outputs.result).hasEnoughApprovals &&
        !fromJSON(steps.check-reviews.outputs.result).hasRejections
      with:
        script: |
          const prInfo = ${{ steps.pr-info.outputs.result }};
          
          try {
            // åŸ·è¡Œåˆä½µ
            const { data: merge } = await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prInfo.number,
              commit_title: `ğŸ¤– Auto-merge: ${prInfo.title}`,
              commit_message: `
              è‡ªå‹•åˆä½µ PR #${prInfo.number}
              
              ä½œè€…: @${prInfo.author}
              åˆ†æ”¯: ${prInfo.headBranch} â†’ ${prInfo.baseBranch}
              
              ğŸ¤– æ­¤ PR å·²é€šéæ‰€æœ‰å¿…è¦æª¢æŸ¥å’Œå¯©æŸ¥ï¼Œè‡ªå‹•åˆä½µå®Œæˆã€‚
              `,
              merge_method: prInfo.baseBranch === 'main' ? 'squash' : 'merge'
            });
            
            console.log(`âœ… PR #${prInfo.number} å·²æˆåŠŸè‡ªå‹•åˆä½µ`);
            
            // æ·»åŠ æˆåŠŸè©•è«–
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prInfo.number,
              body: `ğŸ‰ **è‡ªå‹•åˆä½µæˆåŠŸï¼**
              
              âœ… æ‰€æœ‰æª¢æŸ¥å·²é€šé
              âœ… å¯©æŸ¥è¦æ±‚å·²æ»¿è¶³
              âœ… å·²è‡ªå‹•åˆä½µåˆ° \`${prInfo.baseBranch}\` åˆ†æ”¯
              
              Merge SHA: \`${merge.sha}\`
              
              æ„Ÿè¬ @${prInfo.author} çš„è²¢ç»ï¼ ğŸš€`
            });
            
            return { success: true, sha: merge.sha };
            
          } catch (error) {
            console.error('è‡ªå‹•åˆä½µå¤±æ•—:', error);
            
            // æ·»åŠ å¤±æ•—è©•è«–
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prInfo.number,
              body: `âŒ **è‡ªå‹•åˆä½µå¤±æ•—**
              
              éŒ¯èª¤åŸå› : ${error.message}
              
              è«‹æª¢æŸ¥æ˜¯å¦æœ‰åˆä½µè¡çªæˆ–å…¶ä»–å•é¡Œï¼Œå¯èƒ½éœ€è¦æ‰‹å‹•è™•ç†ã€‚ ğŸ”§`
            });
            
            return { success: false, error: error.message };
          }
    
    - name: ğŸ“‹ è¼¸å‡ºè™•ç†çµæœ
      if: always()
      run: |
        echo "ğŸ¤– è‡ªå‹•åˆä½µè™•ç†å®Œæˆ"
        echo ""
        
        PR_RESULT='${{ steps.pr-info.outputs.result }}'
        
        # æª¢æŸ¥æ˜¯å¦æ‡‰è©²è·³éè™•ç†
        if [[ "$PR_RESULT" == *"shouldSkip\":true"* ]]; then
          echo "â­ï¸ è·³éè™•ç†ï¼šæ²’æœ‰æ‰¾åˆ°ç›¸é—œçš„ PR"
          exit 0
        fi
        
        LABELS_RESULT='${{ steps.check-labels.outputs.result }}'
        STATUS_RESULT='${{ steps.check-status.outputs.result }}'
        REVIEWS_RESULT='${{ steps.check-reviews.outputs.result }}'
        MERGE_RESULT='${{ steps.merge.outputs.result }}'
        
        echo "ğŸ“Š æª¢æŸ¥çµæœæ‘˜è¦:"
        
        if [[ "$LABELS_RESULT" == *"canAutoMerge\":false"* ]]; then
          echo "ğŸ·ï¸ æ¨™ç±¤æª¢æŸ¥: âŒ ä¸ç¬¦åˆè‡ªå‹•åˆä½µæ¢ä»¶"
          echo "   åŸå› : $(echo "$LABELS_RESULT" | jq -r '.reason')"
        else
          echo "ğŸ·ï¸ æ¨™ç±¤æª¢æŸ¥: âœ… é€šé"
          
          if [[ "$STATUS_RESULT" == *"allChecksPassed\":false"* ]]; then
            echo "âš¡ ç‹€æ…‹æª¢æŸ¥: âŒ æœªé€šé"
            echo "   å¤±æ•—æª¢æŸ¥: $(echo "$STATUS_RESULT" | jq -r '.failedChecks[]' | tr '\n' ',' | sed 's/,$//')"
            echo "   å¾…è™•ç†æª¢æŸ¥: $(echo "$STATUS_RESULT" | jq -r '.pendingChecks[]' | tr '\n' ',' | sed 's/,$//')"
          else
            echo "âš¡ ç‹€æ…‹æª¢æŸ¥: âœ… é€šé"
            
            if [[ "$REVIEWS_RESULT" == *"hasRejections\":true"* ]]; then
              echo "ğŸ‘¥ å¯©æŸ¥æª¢æŸ¥: âŒ æœ‰æ‹’çµ•çš„å¯©æŸ¥"
            elif [[ "$REVIEWS_RESULT" == *"hasEnoughApprovals\":false"* ]]; then
              echo "ğŸ‘¥ å¯©æŸ¥æª¢æŸ¥: âŒ å¯©æŸ¥ä¸è¶³"
              echo "   éœ€è¦: $(echo "$REVIEWS_RESULT" | jq -r '.requiredApprovals') å€‹æ‰¹å‡†"
              echo "   ç•¶å‰: $(echo "$REVIEWS_RESULT" | jq -r '.approvals') å€‹æ‰¹å‡†"
            else
              echo "ğŸ‘¥ å¯©æŸ¥æª¢æŸ¥: âœ… é€šé"
              
              if [[ "$MERGE_RESULT" == *"success\":true"* ]]; then
                echo "ğŸ‰ è‡ªå‹•åˆä½µ: âœ… æˆåŠŸå®Œæˆ"
                echo "   SHA: $(echo "$MERGE_RESULT" | jq -r '.sha')"
              else
                echo "âŒ è‡ªå‹•åˆä½µ: å¤±æ•—"
                echo "   éŒ¯èª¤: $(echo "$MERGE_RESULT" | jq -r '.error // "æœªçŸ¥éŒ¯èª¤"')"
              fi
            fi
          fi
        fi