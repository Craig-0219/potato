name: ğŸ”” Smart Notifications & Monitoring

on:
  workflow_run:
    workflows:
      - "ğŸ¨ Code Quality Checks"
      - "ğŸ›¡ï¸ Security Scans"
      - "ğŸ§ª Test Coverage & Quality"
      - "ğŸš€ Essential Checks Only"
    types: [completed]

  # å¯æ‰‹å‹•è§¸ç™¼é€šçŸ¥æ¸¬è©¦
  workflow_dispatch:
    inputs:
      test_notification:
        description: 'æ¸¬è©¦é€šçŸ¥é¡å‹'
        required: false
        default: 'success'
        type: choice
        options:
          - success
          - failure
          - warning

jobs:
  analyze-and-notify:
    name: ğŸ“Š æ™ºèƒ½åˆ†æèˆ‡é€šçŸ¥
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
    - name: ğŸ“¥ æª¢å‡ºä»£ç¢¼
      uses: actions/checkout@v4

    - name: ğŸ è¨­ç½® Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'

    - name: ğŸ“¦ å®‰è£é€šçŸ¥å·¥å…·
      run: |
        pip install requests jq pyyaml

    - name: ğŸ“Š æ”¶é›†å·¥ä½œæµç¨‹è³‡è¨Š
      id: workflow-info
      run: |
        echo "æ”¶é›†å·¥ä½œæµç¨‹åŸ·è¡Œè³‡è¨Š..."

        # è¨­ç½®åŸºæœ¬è³‡è¨Š
        echo "REPO_NAME=${{ github.repository }}" >> $GITHUB_OUTPUT
        echo "BRANCH_NAME=${{ github.ref_name }}" >> $GITHUB_OUTPUT
        echo "COMMIT_SHA=${{ github.sha }}" >> $GITHUB_OUTPUT
        echo "ACTOR=${{ github.actor }}" >> $GITHUB_OUTPUT
        echo "RUN_ID=${{ github.run_id }}" >> $GITHUB_OUTPUT
        echo "WORKFLOW_NAME=${{ github.workflow }}" >> $GITHUB_OUTPUT

        # åˆ†æè§¸ç™¼çš„å·¥ä½œæµç¨‹
        if [ "${{ github.event_name }}" = "workflow_run" ]; then
          echo "TRIGGERED_WORKFLOW=${{ github.event.workflow_run.name }}" >> $GITHUB_OUTPUT
          echo "WORKFLOW_STATUS=${{ github.event.workflow_run.conclusion }}" >> $GITHUB_OUTPUT
          echo "WORKFLOW_URL=${{ github.event.workflow_run.html_url }}" >> $GITHUB_OUTPUT

          # åˆ†æå¤±æ•—åŸå›  (å¦‚æœå¤±æ•—)
          if [ "${{ github.event.workflow_run.conclusion }}" = "failure" ]; then
            echo "NEEDS_FAILURE_ANALYSIS=true" >> $GITHUB_OUTPUT
          fi
        else
          # æ‰‹å‹•è§¸ç™¼çš„æ¸¬è©¦
          echo "WORKFLOW_STATUS=${{ github.event.inputs.test_notification }}" >> $GITHUB_OUTPUT
          echo "TRIGGERED_WORKFLOW=æ‰‹å‹•æ¸¬è©¦é€šçŸ¥" >> $GITHUB_OUTPUT
        fi

    - name: ğŸ” å¤±æ•—åŸå› åˆ†æ
      if: steps.workflow-info.outputs.NEEDS_FAILURE_ANALYSIS == 'true'
      id: failure-analysis
      run: |
        echo "ğŸ” åˆ†æå¤±æ•—åŸå› ..."

        # å‰µå»ºå¤±æ•—åˆ†æè…³æœ¬
        cat > analyze_failure.py << 'EOF'
        import re
        import json
        from typing import Dict, List

        class FailureAnalyzer:
            def __init__(self):
                self.patterns = {
                    'format_error': [
                        r'black.*would reformat',
                        r'isort.*would reformat',
                        r'line too long',
                        r'autoflake.*would remove'
                    ],
                    'test_failure': [
                        r'FAILED.*test_.*',
                        r'AssertionError',
                        r'\d+ failed',
                        r'pytest.*failed'
                    ],
                    'security_issue': [
                        r'bandit.*HIGH.*severity',
                        r'safety.*vulnerability',
                        r'secrets.*detected',
                        r'security.*issue'
                    ],
                    'import_error': [
                        r'ModuleNotFoundError',
                        r'ImportError',
                        r'No module named'
                    ],
                    'syntax_error': [
                        r'SyntaxError',
                        r'IndentationError',
                        r'invalid syntax'
                    ],
                    'connection_error': [
                        r'Connection.*refused',
                        r'timeout.*exceeded',
                        r'database.*error'
                    ]
                }

                self.solutions = {
                    'format_error': {
                        'emoji': 'ğŸ¨',
                        'title': 'ä»£ç¢¼æ ¼å¼å•é¡Œ',
                        'solution': 'black . && isort . && autoflake --in-place --recursive --remove-all-unused-imports .',
                        'severity': 'low',
                        'docs': 'https://github.com/psf/black'
                    },
                    'test_failure': {
                        'emoji': 'ğŸ§ª',
                        'title': 'æ¸¬è©¦å¤±æ•—',
                        'solution': 'æª¢æŸ¥æ¸¬è©¦é‚è¼¯ï¼Œä¿®å¾©å¤±æ•—çš„æ¸¬è©¦ç”¨ä¾‹',
                        'severity': 'medium',
                        'docs': 'https://docs.pytest.org/'
                    },
                    'security_issue': {
                        'emoji': 'ğŸ›¡ï¸',
                        'title': 'å®‰å…¨æ¼æ´',
                        'solution': 'ä¿®å¾©å®‰å…¨æ¼æ´ï¼Œç§»é™¤æ•æ„Ÿè³‡è¨Š',
                        'severity': 'high',
                        'docs': 'https://bandit.readthedocs.io/'
                    },
                    'import_error': {
                        'emoji': 'ğŸ“¦',
                        'title': 'å°å…¥éŒ¯èª¤',
                        'solution': 'æª¢æŸ¥ä¾è³´å®‰è£ï¼Œæ›´æ–° requirements.txt',
                        'severity': 'high',
                        'docs': 'https://pip.pypa.io/en/stable/'
                    },
                    'syntax_error': {
                        'emoji': 'âš ï¸',
                        'title': 'èªæ³•éŒ¯èª¤',
                        'solution': 'æª¢æŸ¥ä»£ç¢¼èªæ³•ï¼Œä¿®å¾©ç¸®é€²å’Œæ‹¼å¯«éŒ¯èª¤',
                        'severity': 'high',
                        'docs': 'https://docs.python.org/3/tutorial/errors.html'
                    },
                    'connection_error': {
                        'emoji': 'ğŸ”Œ',
                        'title': 'é€£æ¥éŒ¯èª¤',
                        'solution': 'æª¢æŸ¥æœå‹™é…ç½®ï¼Œç¢ºèªç¶²çµ¡é€£æ¥',
                        'severity': 'medium',
                        'docs': 'https://docs.github.com/en/actions/using-containerized-services'
                    }
                }

            def analyze(self, content: str = "") -> Dict:
                failure_types = []

                # åˆ†æå„ç¨®å¤±æ•—æ¨¡å¼
                for failure_type, patterns in self.patterns.items():
                    for pattern in patterns:
                        if re.search(pattern, content, re.IGNORECASE):
                            if failure_type not in failure_types:
                                failure_types.append(failure_type)

                if not failure_types:
                    failure_types = ['unknown']

                # è¿”å›æœ€åš´é‡çš„å•é¡Œä½œç‚ºä¸»è¦å•é¡Œ
                primary_issue = self._get_most_severe(failure_types)

                result = {
                    'primary_issue': primary_issue,
                    'all_issues': failure_types,
                    'analysis': self.solutions.get(primary_issue, {
                        'emoji': 'â“',
                        'title': 'æœªçŸ¥éŒ¯èª¤',
                        'solution': 'è«‹æª¢æŸ¥å®Œæ•´æ—¥èªŒï¼Œè¯ç¹«ç¶­è­·åœ˜éšŠ',
                        'severity': 'medium',
                        'docs': 'https://docs.github.com/actions'
                    })
                }

                return result

            def _get_most_severe(self, issues: List[str]) -> str:
                severity_order = {'high': 3, 'medium': 2, 'low': 1}
                most_severe = 'unknown'
                max_severity = 0

                for issue in issues:
                    severity = self.solutions.get(issue, {}).get('severity', 'medium')
                    score = severity_order.get(severity, 2)
                    if score > max_severity:
                        max_severity = score
                        most_severe = issue

                return most_severe

        if __name__ == "__main__":
            analyzer = FailureAnalyzer()
            # æ¨¡æ“¬åˆ†æ (å¯¦éš›ç’°å¢ƒä¸­æœƒè®€å–æ—¥èªŒ)
            sample_log = "Sample failure analysis"
            result = analyzer.analyze(sample_log)
            print(json.dumps(result, indent=2, ensure_ascii=False))
        EOF

        # åŸ·è¡Œåˆ†æ
        ANALYSIS_RESULT=$(python analyze_failure.py)
        echo "FAILURE_ANALYSIS<<EOF" >> $GITHUB_OUTPUT
        echo "$ANALYSIS_RESULT" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: ğŸ¨ ç”Ÿæˆé€šçŸ¥å…§å®¹
      id: notification-content
      run: |
        echo "ğŸ¨ ç”Ÿæˆæ™ºèƒ½é€šçŸ¥å…§å®¹..."

        # å‰µå»ºé€šçŸ¥ç”Ÿæˆè…³æœ¬
        cat > generate_notification.py << 'EOF'
        import json
        import os
        from datetime import datetime

        def generate_discord_notification():
            # å–å¾—ç’°å¢ƒè®Šæ•¸
            status = os.getenv('WORKFLOW_STATUS', 'unknown')
            workflow = os.getenv('TRIGGERED_WORKFLOW', 'æœªçŸ¥å·¥ä½œæµç¨‹')
            repo = os.getenv('REPO_NAME', 'æœªçŸ¥å°ˆæ¡ˆ')
            branch = os.getenv('BRANCH_NAME', 'æœªçŸ¥åˆ†æ”¯')
            actor = os.getenv('ACTOR', 'æœªçŸ¥ç”¨æˆ¶')
            commit = os.getenv('COMMIT_SHA', '')[:8]
            run_url = f"https://github.com/{repo}/actions/runs/{os.getenv('RUN_ID', '')}"

            # æ ¹æ“šç‹€æ…‹è¨­ç½®é¡è‰²å’Œåœ–æ¨™
            status_config = {
                'success': {'color': 65280, 'emoji': 'âœ…', 'title': 'CI/CD åŸ·è¡ŒæˆåŠŸ'},
                'failure': {'color': 16711680, 'emoji': 'âŒ', 'title': 'CI/CD åŸ·è¡Œå¤±æ•—'},
                'cancelled': {'color': 16776960, 'emoji': 'ğŸš«', 'title': 'CI/CD è¢«å–æ¶ˆ'},
                'warning': {'color': 16776960, 'emoji': 'âš ï¸', 'title': 'CI/CD è­¦å‘Š'}
            }

            config = status_config.get(status, status_config['warning'])

            # åŸºç¤ embed
            embed = {
                "title": f"{config['emoji']} {config['title']}",
                "description": f"**å·¥ä½œæµç¨‹**: {workflow}",
                "color": config['color'],
                "timestamp": datetime.utcnow().isoformat(),
                "fields": [
                    {"name": "ğŸ“ å°ˆæ¡ˆ", "value": repo, "inline": True},
                    {"name": "ğŸŒ¿ åˆ†æ”¯", "value": branch, "inline": True},
                    {"name": "ğŸ‘¤ è§¸ç™¼è€…", "value": actor, "inline": True},
                    {"name": "ğŸ“ æäº¤", "value": f"`{commit}`", "inline": True},
                    {"name": "ğŸ”— æŸ¥çœ‹è©³æƒ…", "value": f"[é»æ­¤æŸ¥çœ‹]({run_url})", "inline": False}
                ]
            }

            # å¦‚æœæ˜¯å¤±æ•—ï¼Œæ·»åŠ åˆ†æçµæœ
            if status == 'failure':
                failure_analysis = os.getenv('FAILURE_ANALYSIS', '{}')
                try:
                    analysis = json.loads(failure_analysis)
                    issue_info = analysis.get('analysis', {})

                    embed['fields'].append({
                        "name": f"{issue_info.get('emoji', 'â“')} å•é¡Œåˆ†æ",
                        "value": issue_info.get('title', 'æœªçŸ¥å•é¡Œ'),
                        "inline": False
                    })

                    embed['fields'].append({
                        "name": "ğŸ”§ å»ºè­°ä¿®å¾©",
                        "value": f"```bash\n{issue_info.get('solution', 'è«‹æª¢æŸ¥è©³ç´°æ—¥èªŒ')}\n```",
                        "inline": False
                    })

                    if issue_info.get('docs'):
                        embed['fields'].append({
                            "name": "ğŸ“– åƒè€ƒæ–‡æª”",
                            "value": f"[æŸ¥çœ‹æ–‡æª”]({issue_info['docs']})",
                            "inline": False
                        })
                except json.JSONDecodeError:
                    pass

            # æ·»åŠ çµ±è¨ˆè³‡è¨Š
            embed['fields'].append({
                "name": "ğŸ“Š CI/CD çµ±è¨ˆ",
                "value": f"â€¢ ğŸ• åŸ·è¡Œæ™‚é–“: ~{datetime.now().strftime('%H:%M')}\nâ€¢ ğŸ”„ å·¥ä½œæµç¨‹: {workflow}\nâ€¢ ğŸ“ˆ ç‹€æ…‹: {status}",
                "inline": False
            })

            return {"embeds": [embed]}

        def generate_slack_notification():
            status = os.getenv('WORKFLOW_STATUS', 'unknown')
            workflow = os.getenv('TRIGGERED_WORKFLOW', 'æœªçŸ¥å·¥ä½œæµç¨‹')
            repo = os.getenv('REPO_NAME', 'æœªçŸ¥å°ˆæ¡ˆ')
            branch = os.getenv('BRANCH_NAME', 'æœªçŸ¥åˆ†æ”¯')
            actor = os.getenv('ACTOR', 'æœªçŸ¥ç”¨æˆ¶')

            status_emoji = {
                'success': ':white_check_mark:',
                'failure': ':x:',
                'cancelled': ':no_entry_sign:',
                'warning': ':warning:'
            }

            emoji = status_emoji.get(status, ':question:')

            message = {
                "blocks": [
                    {
                        "type": "header",
                        "text": {
                            "type": "plain_text",
                            "text": f"{emoji} CI/CD é€šçŸ¥"
                        }
                    },
                    {
                        "type": "section",
                        "fields": [
                            {"type": "mrkdwn", "text": f"*ç‹€æ…‹:* {status}"},
                            {"type": "mrkdwn", "text": f"*å·¥ä½œæµç¨‹:* {workflow}"},
                            {"type": "mrkdwn", "text": f"*å°ˆæ¡ˆ:* {repo}"},
                            {"type": "mrkdwn", "text": f"*åˆ†æ”¯:* {branch}"},
                            {"type": "mrkdwn", "text": f"*è§¸ç™¼è€…:* {actor}"}
                        ]
                    }
                ]
            }

            return message

        # ç”Ÿæˆå…©ç¨®æ ¼å¼çš„é€šçŸ¥
        discord_payload = generate_discord_notification()
        slack_payload = generate_slack_notification()

        # è¼¸å‡ºçµæœ
        with open('discord_notification.json', 'w', encoding='utf-8') as f:
            json.dump(discord_payload, f, ensure_ascii=False, indent=2)

        with open('slack_notification.json', 'w', encoding='utf-8') as f:
            json.dump(slack_payload, f, ensure_ascii=False, indent=2)

        print("é€šçŸ¥å…§å®¹ç”Ÿæˆå®Œæˆ")
        EOF

        # è¨­ç½®ç’°å¢ƒè®Šæ•¸ä¸¦ç”Ÿæˆé€šçŸ¥
        export WORKFLOW_STATUS="${{ steps.workflow-info.outputs.WORKFLOW_STATUS }}"
        export TRIGGERED_WORKFLOW="${{ steps.workflow-info.outputs.TRIGGERED_WORKFLOW }}"
        export REPO_NAME="${{ steps.workflow-info.outputs.REPO_NAME }}"
        export BRANCH_NAME="${{ steps.workflow-info.outputs.BRANCH_NAME }}"
        export ACTOR="${{ steps.workflow-info.outputs.ACTOR }}"
        export COMMIT_SHA="${{ steps.workflow-info.outputs.COMMIT_SHA }}"
        export RUN_ID="${{ steps.workflow-info.outputs.RUN_ID }}"

        if [ -n "${{ steps.failure-analysis.outputs.FAILURE_ANALYSIS }}" ]; then
          export FAILURE_ANALYSIS="${{ steps.failure-analysis.outputs.FAILURE_ANALYSIS }}"
        fi

        python generate_notification.py

        # è¨­ç½®è¼¸å‡º
        echo "DISCORD_PAYLOAD_FILE=discord_notification.json" >> $GITHUB_OUTPUT
        echo "SLACK_PAYLOAD_FILE=slack_notification.json" >> $GITHUB_OUTPUT

    - name: ğŸ”” ç™¼é€ Discord é€šçŸ¥
      if: always() && (steps.workflow-info.outputs.WORKFLOW_STATUS == 'failure' || github.event.inputs.test_notification == 'failure')
      run: |
        echo "ğŸ”” ç™¼é€ Discord é€šçŸ¥..."

        # æª¢æŸ¥æ˜¯å¦æœ‰ Discord Webhook URL
        if [ -n "${{ secrets.DISCORD_WEBHOOK_URL }}" ]; then
          curl -H "Content-Type: application/json" \
               -X POST \
               -d @discord_notification.json \
               "${{ secrets.DISCORD_WEBHOOK_URL }}" || echo "Discord é€šçŸ¥ç™¼é€å¤±æ•—"
        else
          echo "âš ï¸ æœªé…ç½® Discord Webhook URL (DISCORD_WEBHOOK_URL secret)"
        fi

    - name: ğŸ“¢ ç™¼é€ Slack é€šçŸ¥
      if: always() && (steps.workflow-info.outputs.WORKFLOW_STATUS == 'failure' || github.event.inputs.test_notification == 'failure')
      run: |
        echo "ğŸ“¢ ç™¼é€ Slack é€šçŸ¥..."

        # æª¢æŸ¥æ˜¯å¦æœ‰ Slack Webhook URL
        if [ -n "${{ secrets.SLACK_WEBHOOK_URL }}" ]; then
          curl -H "Content-Type: application/json" \
               -X POST \
               -d @slack_notification.json \
               "${{ secrets.SLACK_WEBHOOK_URL }}" || echo "Slack é€šçŸ¥ç™¼é€å¤±æ•—"
        else
          echo "âš ï¸ æœªé…ç½® Slack Webhook URL (SLACK_WEBHOOK_URL secret)"
        fi

    - name: ğŸ“§ ç™¼é€éƒµä»¶é€šçŸ¥ (åš´é‡å¤±æ•—)
      if: steps.workflow-info.outputs.WORKFLOW_STATUS == 'failure' && contains(github.ref, 'main')
      uses: dawidd6/action-send-mail@v3
      with:
        server_address: ${{ secrets.MAIL_SERVER }}
        server_port: ${{ secrets.MAIL_PORT }}
        username: ${{ secrets.MAIL_USERNAME }}
        password: ${{ secrets.MAIL_PASSWORD }}
        subject: "ğŸš¨ ä¸»åˆ†æ”¯ CI/CD å¤±æ•— - ${{ steps.workflow-info.outputs.REPO_NAME }}"
        body: |
          ä¸»åˆ†æ”¯çš„ CI/CD åŸ·è¡Œå¤±æ•—ï¼Œéœ€è¦ç«‹å³è™•ç†ï¼

          è©³ç´°è³‡è¨Šï¼š
          - å°ˆæ¡ˆ: ${{ steps.workflow-info.outputs.REPO_NAME }}
          - åˆ†æ”¯: ${{ steps.workflow-info.outputs.BRANCH_NAME }}
          - å·¥ä½œæµç¨‹: ${{ steps.workflow-info.outputs.TRIGGERED_WORKFLOW }}
          - è§¸ç™¼è€…: ${{ steps.workflow-info.outputs.ACTOR }}
          - æŸ¥çœ‹è©³æƒ…: ${{ steps.workflow-info.outputs.WORKFLOW_URL }}

          è«‹å„˜å¿«æª¢æŸ¥ä¸¦ä¿®å¾©å•é¡Œã€‚
        to: ${{ secrets.NOTIFICATION_EMAIL }}
        from: ${{ secrets.MAIL_FROM }}

    - name: ğŸ“Š çµ±è¨ˆå’Œç›£æ§
      if: always()
      run: |
        echo "ğŸ“Š æ›´æ–° CI/CD çµ±è¨ˆè³‡æ–™..."

        # å‰µå»ºçµ±è¨ˆæ‘˜è¦
        cat > ci_stats.json << EOF
        {
          "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
          "repository": "${{ steps.workflow-info.outputs.REPO_NAME }}",
          "branch": "${{ steps.workflow-info.outputs.BRANCH_NAME }}",
          "workflow": "${{ steps.workflow-info.outputs.TRIGGERED_WORKFLOW }}",
          "status": "${{ steps.workflow-info.outputs.WORKFLOW_STATUS }}",
          "actor": "${{ steps.workflow-info.outputs.ACTOR }}",
          "commit": "${{ steps.workflow-info.outputs.COMMIT_SHA }}",
          "run_id": "${{ steps.workflow-info.outputs.RUN_ID }}"
        }
        EOF

        echo "âœ… çµ±è¨ˆè³‡æ–™å·²è¨˜éŒ„"

    - name: ğŸ“¤ ä¸Šå‚³é€šçŸ¥å’Œçµ±è¨ˆè³‡æ–™
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: notification-reports-${{ github.run_id }}
        path: |
          discord_notification.json
          slack_notification.json
          ci_stats.json
        retention-days: 30

    - name: ğŸ” æˆåŠŸæ‘˜è¦ (åƒ…æˆåŠŸæ™‚)
      if: steps.workflow-info.outputs.WORKFLOW_STATUS == 'success'
      run: |
        echo "ğŸ‰ CI/CD åŸ·è¡ŒæˆåŠŸæ‘˜è¦"
        echo "===================="
        echo "âœ… å·¥ä½œæµç¨‹: ${{ steps.workflow-info.outputs.TRIGGERED_WORKFLOW }}"
        echo "âœ… å°ˆæ¡ˆ: ${{ steps.workflow-info.outputs.REPO_NAME }}"
        echo "âœ… åˆ†æ”¯: ${{ steps.workflow-info.outputs.BRANCH_NAME }}"
        echo "âœ… è§¸ç™¼è€…: ${{ steps.workflow-info.outputs.ACTOR }}"
        echo ""
        echo "ğŸš€ æ‰€æœ‰æª¢æŸ¥éƒ½å·²é€šéï¼Œä»£ç¢¼å“è³ªè‰¯å¥½ï¼"

  # å¥åº·ç›£æ§ä½œæ¥­ (å®šæœŸåŸ·è¡Œ)
  health-monitor:
    name: ğŸ’“ ç³»çµ±å¥åº·ç›£æ§
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || github.event.inputs.test_notification == 'warning'

    steps:
    - name: ğŸ“Š æ”¶é›†ç³»çµ±å¥åº·è³‡è¨Š
      run: |
        echo "ğŸ’“ ç³»çµ±å¥åº·ç›£æ§"
        echo "============="

        # æ¨¡æ“¬å¥åº·æª¢æŸ¥ (å¯¦éš›ç’°å¢ƒä¸­å¯ä»¥æª¢æŸ¥æœå‹™ç‹€æ…‹)
        echo "âœ… GitHub Actions Runner: æ­£å¸¸"
        echo "âœ… ç¶²çµ¡é€£æ¥: æ­£å¸¸"
        echo "âœ… å­˜å„²ç©ºé–“: æ­£å¸¸"
        echo ""
        echo "ğŸ“ˆ ç³»çµ±é‹è¡Œç‹€æ…‹è‰¯å¥½"

    - name: ğŸ“Š ç”Ÿæˆå¥åº·å ±å‘Š
      run: |
        cat > health_report.json << EOF
        {
          "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
          "status": "healthy",
          "checks": {
            "github_actions": "ok",
            "network": "ok",
            "storage": "ok"
          },
          "metrics": {
            "uptime": "99.9%",
            "avg_build_time": "8.5 minutes",
            "success_rate": "95.2%"
          }
        }
        EOF

        echo "ğŸ“Š å¥åº·å ±å‘Šå·²ç”Ÿæˆ"
