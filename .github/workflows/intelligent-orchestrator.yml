name: ğŸ­ Intelligent Execution Orchestrator

on:
  push:
    branches: [dev]
  pull_request:
    branches: [dev, main]
  workflow_dispatch:
    inputs:
      execution_mode:
        description: 'åŸ·è¡Œæ¨¡å¼'
        required: false
        default: 'auto'
        type: choice
        options:
          - auto      # è‡ªå‹•æ™ºèƒ½æ±ºç­–
          - full      # å®Œæ•´åŸ·è¡Œæ‰€æœ‰æª¢æŸ¥
          - quick     # å¿«é€Ÿæª¢æŸ¥
          - targeted  # é‡å°æ€§æª¢æŸ¥
      force_execution:
        description: 'å¼·åˆ¶åŸ·è¡Œæ‰€æœ‰ workflows'
        required: false
        default: false
        type: boolean

env:
  ORCHESTRATOR_VERSION: v2.0.0

jobs:
  # ç¬¬ä¸€éšæ®µï¼šæ™ºèƒ½åˆ†æå’Œæ±ºç­–
  intelligent-analysis:
    name: ğŸ§  æ™ºèƒ½åˆ†æèˆ‡æ±ºç­–
    runs-on: ubuntu-latest
    timeout-minutes: 5
    
    outputs:
      execution_plan: ${{ steps.analysis.outputs.execution_plan }}
      change_type: ${{ steps.analysis.outputs.change_type }}
      impact_level: ${{ steps.analysis.outputs.impact_level }}
      test_strategy: ${{ steps.analysis.outputs.test_strategy }}
      cache_strategy: ${{ steps.analysis.outputs.cache_strategy }}
      estimated_time: ${{ steps.analysis.outputs.estimated_time }}
      workflows_to_run: ${{ steps.analysis.outputs.workflows_to_run }}
      workflows_to_skip: ${{ steps.analysis.outputs.workflows_to_skip }}
    
    steps:
    - name: ğŸ“¥ æª¢å‡ºä»£ç¢¼
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: ğŸ§  åŸ·è¡Œæ™ºèƒ½åˆ†æ
      id: analysis
      run: |
        cat << 'EOF' > intelligent_analysis.py
        import os
        import re
        import json
        from typing import Dict, List, Any
        
        def analyze_changes() -> Dict[str, Any]:
            """åŸ·è¡Œæ™ºèƒ½è®Šæ›´åˆ†æå’ŒåŸ·è¡Œç­–ç•¥æ±ºç­–"""
            
            # ç²å–è®Šæ›´çš„æª”æ¡ˆ
            if os.environ.get('GITHUB_EVENT_NAME') == 'pull_request':
                # PR æ¨¡å¼
                changed_files_cmd = f"git diff --name-only origin/{os.environ.get('GITHUB_BASE_REF', 'main')}...HEAD"
            else:
                # Push æ¨¡å¼
                changed_files_cmd = "git diff --name-only HEAD~1 HEAD"
            
            import subprocess
            result = subprocess.run(changed_files_cmd, shell=True, capture_output=True, text=True)
            changed_files = [f for f in result.stdout.strip().split('\n') if f.strip()]
            
            if not changed_files:
                return {
                    'execution_plan': 'minimal',
                    'change_type': 'none',
                    'impact_level': 'none',
                    'test_strategy': 'skip',
                    'cache_strategy': 'preserve',
                    'estimated_time': 2,
                    'workflows_to_run': [],
                    'workflows_to_skip': ['all']
                }
            
            print(f"ğŸ“Š åˆ†æ {len(changed_files)} å€‹è®Šæ›´æª”æ¡ˆ:")
            for f in changed_files[:10]:  # åªé¡¯ç¤ºå‰10å€‹
                print(f"  â€¢ {f}")
            if len(changed_files) > 10:
                print(f"  â€¢ ... ä»¥åŠå…¶ä»– {len(changed_files) - 10} å€‹æª”æ¡ˆ")
            
            # æª”æ¡ˆåˆ†é¡è¦å‰‡
            categories = {
                'critical': [
                    r'^bot/main\.py$',
                    r'^shared/config\.py$',
                    r'^requirements.*\.txt$',
                    r'^\.github/workflows/.*\.yml$'
                ],
                'core_logic': [
                    r'^bot/cogs/.*\.py$',
                    r'^bot/services/.*\.py$',
                    r'^bot/db/.*\.py$',
                    r'^shared/.*\.py$'
                ],
                'api': [
                    r'^bot/api/.*\.py$',
                    r'^bot/views/.*\.py$'
                ],
                'tests': [
                    r'^tests/.*\.py$'
                ],
                'docs': [
                    r'.*\.md$',
                    r'^docs/.*',
                    r'README.*',
                    r'CHANGELOG.*'
                ],
                'config': [
                    r'^\\..*rc$',
                    r'^\\..*\\.yaml$',
                    r'^\\..*\\.yml$',
                    r'^pyproject\\.toml$',
                    r'^pytest\\.ini$'
                ]
            }
            
            # åˆ†ææª”æ¡ˆé¡åˆ¥
            file_categories = {}
            for file_path in changed_files:
                file_categories[file_path] = []
                for category, patterns in categories.items():
                    for pattern in patterns:
                        if re.match(pattern, file_path):
                            file_categories[file_path].append(category)
                            break
                
                if not file_categories[file_path]:
                    file_categories[file_path] = ['other']
            
            # çµ±è¨ˆå„é¡åˆ¥æª”æ¡ˆæ•¸é‡
            category_counts = {}
            for categories_list in file_categories.values():
                for cat in categories_list:
                    category_counts[cat] = category_counts.get(cat, 0) + 1
            
            print(f"\\nğŸ“ˆ è®Šæ›´æª”æ¡ˆåˆ†é¡çµ±è¨ˆ:")
            for cat, count in category_counts.items():
                print(f"  â€¢ {cat}: {count} å€‹æª”æ¡ˆ")
            
            # æ™ºèƒ½æ±ºç­–é‚è¼¯
            execution_plan = 'standard'
            change_type = 'minor'
            impact_level = 'low'
            estimated_time = 8
            
            # æ±ºå®šè®Šæ›´é¡å‹å’Œå½±éŸ¿ç­‰ç´š
            if category_counts.get('critical', 0) > 0:
                change_type = 'critical'
                impact_level = 'high'
                execution_plan = 'comprehensive'
                estimated_time = 15
            elif category_counts.get('core_logic', 0) > 0:
                change_type = 'code'
                impact_level = 'medium'
                execution_plan = 'targeted'
                estimated_time = 10
            elif category_counts.get('api', 0) > 0:
                change_type = 'api'
                impact_level = 'medium'
                execution_plan = 'api_focused'
                estimated_time = 8
            elif category_counts.get('tests', 0) > 0:
                change_type = 'test'
                impact_level = 'low'
                execution_plan = 'test_focused'
                estimated_time = 6
            elif category_counts.get('docs', 0) > 0 and len(category_counts) == 1:
                change_type = 'docs'
                impact_level = 'none'
                execution_plan = 'minimal'
                estimated_time = 3
            elif category_counts.get('config', 0) > 0:
                change_type = 'config'
                impact_level = 'medium'
                execution_plan = 'config_focused'
                estimated_time = 7
            
            # æ±ºå®šæ¸¬è©¦ç­–ç•¥
            test_strategies = {
                'critical': 'full',
                'code': 'targeted', 
                'api': 'api_focused',
                'test': 'test_validation',
                'docs': 'skip',
                'config': 'basic',
                'minor': 'quick'
            }
            test_strategy = test_strategies.get(change_type, 'quick')
            
            # æ±ºå®šå¿«å–ç­–ç•¥
            cache_strategies = {
                'critical': 'refresh',
                'code': 'selective',
                'api': 'selective',
                'docs': 'preserve',
                'config': 'refresh',
                'minor': 'standard'
            }
            cache_strategy = cache_strategies.get(change_type, 'standard')
            
            # æ±ºå®šè¦åŸ·è¡Œå’Œè·³éçš„ workflows
            workflow_plans = {
                'comprehensive': {
                    'run': ['code-quality', 'security-scans', 'test-coverage', 'lightweight-ci'],
                    'skip': []
                },
                'targeted': {
                    'run': ['code-quality', 'lightweight-ci', 'test-coverage'],
                    'skip': ['security-scans']
                },
                'api_focused': {
                    'run': ['code-quality', 'lightweight-ci'],
                    'skip': ['security-scans', 'test-coverage']
                },
                'test_focused': {
                    'run': ['test-coverage', 'lightweight-ci'],
                    'skip': ['code-quality', 'security-scans']
                },
                'config_focused': {
                    'run': ['code-quality', 'lightweight-ci'],
                    'skip': ['security-scans', 'test-coverage']
                },
                'minimal': {
                    'run': ['lightweight-ci'],
                    'skip': ['code-quality', 'security-scans', 'test-coverage']
                }
            }
            
            plan = workflow_plans.get(execution_plan, workflow_plans['targeted'])
            workflows_to_run = plan['run']
            workflows_to_skip = plan['skip']
            
            # è™•ç†æ‰‹å‹•è§¸ç™¼çš„æƒ…æ³
            execution_mode = os.environ.get('EXECUTION_MODE', 'auto')
            force_execution = os.environ.get('FORCE_EXECUTION', 'false') == 'true'
            
            if force_execution or execution_mode == 'full':
                workflows_to_run = ['code-quality', 'security-scans', 'test-coverage', 'lightweight-ci']
                workflows_to_skip = []
                estimated_time = 15
                execution_plan = 'comprehensive'
            elif execution_mode == 'quick':
                workflows_to_run = ['lightweight-ci']
                workflows_to_skip = ['code-quality', 'security-scans', 'test-coverage']
                estimated_time = 5
                execution_plan = 'minimal'
            
            result = {
                'execution_plan': execution_plan,
                'change_type': change_type,
                'impact_level': impact_level,
                'test_strategy': test_strategy,
                'cache_strategy': cache_strategy,
                'estimated_time': estimated_time,
                'workflows_to_run': ','.join(workflows_to_run),
                'workflows_to_skip': ','.join(workflows_to_skip)
            }
            
            print(f"\\nğŸ¯ æ™ºèƒ½åˆ†æçµæœ:")
            print(f"  â€¢ åŸ·è¡Œè¨ˆåŠƒ: {execution_plan}")
            print(f"  â€¢ è®Šæ›´é¡å‹: {change_type}")
            print(f"  â€¢ å½±éŸ¿ç­‰ç´š: {impact_level}")
            print(f"  â€¢ æ¸¬è©¦ç­–ç•¥: {test_strategy}")
            print(f"  â€¢ å¿«å–ç­–ç•¥: {cache_strategy}")
            print(f"  â€¢ é ä¼°æ™‚é–“: {estimated_time} åˆ†é˜")
            print(f"  â€¢ åŸ·è¡Œ workflows: {workflows_to_run}")
            print(f"  â€¢ è·³é workflows: {workflows_to_skip}")
            
            return result
        
        # ä¸»åŸ·è¡Œé‚è¼¯
        if __name__ == '__main__':
            import os
            result = analyze_changes()
            
            # è¼¸å‡ºåˆ° GitHub Actions
            for key, value in result.items():
                print(f"{key}={value}", file=open(os.environ['GITHUB_OUTPUT'], 'a'))
        EOF
        
        # è¨­ç½®ç’°å¢ƒè®Šæ•¸
        export EXECUTION_MODE="${{ inputs.execution_mode }}"
        export FORCE_EXECUTION="${{ inputs.force_execution }}"
        
        # åŸ·è¡Œåˆ†æ
        python intelligent_analysis.py

  # ç¬¬äºŒéšæ®µï¼šæ¢ä»¶è§¸ç™¼ workflows (ä½¿ç”¨ workflow_dispatch API)
  trigger-workflows:
    name: ğŸš€ æ¢ä»¶è§¸ç™¼å¾ŒçºŒæª¢æŸ¥
    needs: intelligent-analysis
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: needs.intelligent-analysis.outputs.workflows_to_run != ''
    
    steps:
    - name: ğŸ“¥ æª¢å‡ºä»£ç¢¼
      uses: actions/checkout@v4

    - name: ğŸ­ è§¸ç™¼ç›¸æ‡‰ workflows
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        WORKFLOWS_TO_RUN: ${{ needs.intelligent-analysis.outputs.workflows_to_run }}
        CURRENT_BRANCH: ${{ github.ref_name }}
      run: |
        echo "ğŸ­ æ™ºèƒ½è§¸ç™¼å¾ŒçºŒ workflows"
        echo "åˆ†æ”¯: $CURRENT_BRANCH"
        echo "éœ€è¦åŸ·è¡Œçš„ workflows: $WORKFLOWS_TO_RUN"
        echo ""
        
        REPO="${{ github.repository }}"
        API_BASE="https://api.github.com/repos/$REPO/actions/workflows"
        
        # åˆ†å‰² workflow åˆ—è¡¨
        IFS=',' read -ra WORKFLOWS <<< "$WORKFLOWS_TO_RUN"
        
        for workflow in "${WORKFLOWS[@]}"; do
          workflow=$(echo "$workflow" | xargs)  # ç§»é™¤ç©ºæ ¼
          
          case "$workflow" in
            "code-quality")
              WORKFLOW_FILE="code-quality.yml"
              echo "ğŸ” è§¸ç™¼ä»£ç¢¼å“è³ªæª¢æŸ¥..."
              ;;
            "security-scans")
              WORKFLOW_FILE="security-scans.yml"
              echo "ğŸ”’ è§¸ç™¼å®‰å…¨æƒæ..."
              ;;
            "test-coverage")
              WORKFLOW_FILE="test-coverage.yml"
              echo "ğŸ§ª è§¸ç™¼æ¸¬è©¦è¦†è“‹ç‡æª¢æŸ¥..."
              ;;
            "lightweight-ci")
              WORKFLOW_FILE="lightweight-ci.yml"
              echo "ğŸš€ è§¸ç™¼è¼•é‡ç´š CI..."
              ;;
            *)
              echo "âš ï¸  æœªçŸ¥çš„ workflow: $workflow"
              continue
              ;;
          esac
          
          # ä½¿ç”¨ workflow_dispatch è§¸ç™¼
          curl -s -X POST \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Authorization: token $GITHUB_TOKEN" \
            "$API_BASE/$WORKFLOW_FILE/dispatches" \
            -d "{\"ref\":\"$CURRENT_BRANCH\"}" || true
          
          echo "âœ… $workflow è§¸ç™¼è«‹æ±‚å·²ç™¼é€"
        done
        
        echo ""
        echo "ğŸ¯ æ‰€æœ‰ workflow è§¸ç™¼å®Œæˆï¼"

  # ç¬¬ä¸‰éšæ®µï¼šåŸ·è¡Œç¸½çµå’Œå ±å‘Š
  execution-summary:
    name: ğŸ“‹ åŸ·è¡Œç¸½çµå ±å‘Š
    needs: [intelligent-analysis, trigger-workflows]
    runs-on: ubuntu-latest
    timeout-minutes: 3
    if: always()
    
    steps:
    - name: ğŸ“Š æ™ºèƒ½åŸ·è¡Œç¸½çµ
      run: |
        echo "ğŸ­ æ™ºèƒ½åŸ·è¡Œå”èª¿å™¨ - åŸ·è¡Œç¸½çµå ±å‘Š"
        echo "=============================================="
        echo ""
        
        echo "ğŸ§  æ™ºèƒ½åˆ†æçµæœ:"
        echo "  â€¢ åŸ·è¡Œè¨ˆåŠƒ: ${{ needs.intelligent-analysis.outputs.execution_plan }}"
        echo "  â€¢ è®Šæ›´é¡å‹: ${{ needs.intelligent-analysis.outputs.change_type }}"
        echo "  â€¢ å½±éŸ¿ç­‰ç´š: ${{ needs.intelligent-analysis.outputs.impact_level }}"
        echo "  â€¢ æ¸¬è©¦ç­–ç•¥: ${{ needs.intelligent-analysis.outputs.test_strategy }}"
        echo "  â€¢ å¿«å–ç­–ç•¥: ${{ needs.intelligent-analysis.outputs.cache_strategy }}"
        echo "  â€¢ é ä¼°æ™‚é–“: ${{ needs.intelligent-analysis.outputs.estimated_time }} åˆ†é˜"
        echo ""
        
        echo "ğŸ¯ åŸ·è¡Œçš„ Workflows:"
        WORKFLOWS="${{ needs.intelligent-analysis.outputs.workflows_to_run }}"
        TRIGGER_STATUS="${{ needs.trigger-workflows.result }}"
        
        if [[ -n "$WORKFLOWS" ]]; then
          IFS=',' read -ra WORKFLOW_ARRAY <<< "$WORKFLOWS"
          for workflow in "${WORKFLOW_ARRAY[@]}"; do
            workflow=$(echo "$workflow" | xargs)  # ç§»é™¤ç©ºæ ¼
            case "$workflow" in
              "code-quality")
                echo "  â€¢ ğŸ” Code Quality: å·²è§¸ç™¼"
              ;;
            "security-scans")
                echo "  â€¢ ğŸ”’ Security Scans: å·²è§¸ç™¼"
              ;;
            "test-coverage")
                echo "  â€¢ ğŸ§ª Test Coverage: å·²è§¸ç™¼"
              ;;
            "lightweight-ci")
                echo "  â€¢ ğŸš€ Lightweight CI: å·²è§¸ç™¼"
              ;;
              *)
                echo "  â€¢ â“ $workflow: å·²è§¸ç™¼"
              ;;
            esac
          done
        else
          echo "  â€¢ ç„¡ workflows éœ€è¦åŸ·è¡Œ"
        fi
        
        echo ""
        echo "â­ï¸  è·³éçš„ Workflows:"
        IFS=',' read -ra SKIPPED <<< "${{ needs.intelligent-analysis.outputs.workflows_to_skip }}"
        for workflow in "${SKIPPED[@]}"; do
          case "$workflow" in
            "code-quality")
              echo "  â€¢ ğŸ” Code Quality - è·³é (éä»£ç¢¼å“è³ªç›¸é—œè®Šæ›´)"
              ;;
            "security-scans")
              echo "  â€¢ ğŸ”’ Security Scans - è·³é (ä½é¢¨éšªè®Šæ›´)"
              ;;
            "test-coverage")
              echo "  â€¢ ğŸ§ª Test Coverage - è·³é (ç„¡æ¸¬è©¦éœ€æ±‚)"
              ;;
            "lightweight-ci")
              echo "  â€¢ ğŸš€ Lightweight CI - è·³é (æ–‡æª”è®Šæ›´)"
              ;;
          esac
        done
        
        echo ""
        echo "ğŸ“ˆ æ™ºèƒ½å„ªåŒ–æ•ˆæœ:"
        
        # è¨ˆç®—ç¯€çœçš„æ™‚é–“
        TOTAL_WORKFLOWS=4
        IFS=',' read -ra EXECUTED <<< "${{ needs.intelligent-analysis.outputs.workflows_to_run }}"
        EXECUTED_COUNT=${#EXECUTED[@]}
        SKIPPED_COUNT=$((TOTAL_WORKFLOWS - EXECUTED_COUNT))
        
        ESTIMATED_SAVINGS=$((SKIPPED_COUNT * 3))  # æ¯å€‹ workflow å¹³å‡ç¯€çœ 3 åˆ†é˜
        SKIP_PERCENTAGE=$((SKIPPED_COUNT * 100 / TOTAL_WORKFLOWS))
        
        echo "  â€¢ åŸ·è¡Œ workflows: $EXECUTED_COUNT / $TOTAL_WORKFLOWS"
        echo "  â€¢ æ™ºèƒ½è·³éç‡: ${SKIP_PERCENTAGE}%"
        echo "  â€¢ é ä¼°ç¯€çœæ™‚é–“: $ESTIMATED_SAVINGS åˆ†é˜"
        echo "  â€¢ å¯¦éš›åŸ·è¡Œæ™‚é–“: ${{ needs.intelligent-analysis.outputs.estimated_time }} åˆ†é˜"
        
        echo ""
        if [ $SKIP_PERCENTAGE -ge 25 ]; then
          echo "âœ… æ™ºèƒ½å„ªåŒ–æ•ˆæœé¡¯è‘—ï¼è·³éäº† ${SKIP_PERCENTAGE}% çš„ä¸å¿…è¦æª¢æŸ¥"
        else
          echo "ğŸ“Š æ¨™æº–åŸ·è¡Œæ¨¡å¼ï¼Œç¢ºä¿å®Œæ•´çš„ä»£ç¢¼å“è³ªæª¢æŸ¥"
        fi
        
        echo ""
        echo "ğŸ¯ Stage 2.2 æ™ºèƒ½åŸ·è¡Œç­–ç•¥å·²æˆåŠŸå¯¦æ–½ï¼"