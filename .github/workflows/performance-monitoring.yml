name: 📊 CI/CD Performance Monitoring

on:
  workflow_run:
    workflows: 
      - "🧪 Test Coverage & Quality"
      - "🔍 Code Quality Checks" 
      - "🔒 Security Scans"
      - "⚡ Optimized CI Pipeline"
      - "🚀 Lightweight CI"
    types:
      - completed
  push:
    branches: [dev, main]
    paths:
      - '.github/workflows/performance-monitoring.yml'
  schedule:
    # 每天 UTC 02:00 生成日報告
    - cron: '0 2 * * *'
  workflow_dispatch:
    inputs:
      analysis_type:
        description: '分析類型'
        required: false
        default: 'full'
        type: choice
        options:
          - full
          - trends
          - bottlenecks

env:
  MONITORING_VERSION: v1.0.0

jobs:
  collect-metrics:
    name: 📈 收集效能指標
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion != 'skipped'
    timeout-minutes: 10

    outputs:
      has_data: ${{ steps.collect.outputs.has_data }}
      execution_time: ${{ steps.collect.outputs.execution_time }}
      workflow_name: ${{ steps.collect.outputs.workflow_name }}

    steps:
    - name: 📥 檢出代碼
      uses: actions/checkout@v4
      with:
        fetch-depth: 100  # 獲取更多歷史以進行趨勢分析

    - name: 🐍 設置 Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
        cache: 'pip'

    - name: 📦 安裝監控依賴
      run: |
        pip install requests python-dateutil matplotlib seaborn pandas

    - name: 📊 收集 workflow 執行數據
      id: collect
      run: |
        cat << 'EOF' > collect_metrics.py
        import os
        import sys
        import json
        import requests
        from datetime import datetime, timedelta
        import dateutil.parser
        
        def collect_workflow_metrics():
            """收集 workflow 執行指標"""
            
            # GitHub API 設置
            repo = os.environ.get('GITHUB_REPOSITORY', 'Craig-0219/potato')
            token = os.environ.get('GITHUB_TOKEN')
            
            if not token:
                print("❌ GITHUB_TOKEN not available")
                return None
                
            headers = {
                'Authorization': f'token {token}',
                'Accept': 'application/vnd.github.v3+json'
            }
            
            # 獲取最近 30 次 workflow 執行
            url = f'https://api.github.com/repos/{repo}/actions/runs'
            params = {
                'per_page': 30,
                'branch': 'dev',
                'status': 'completed'
            }
            
            try:
                response = requests.get(url, headers=headers, params=params)
                response.raise_for_status()
                
                runs_data = response.json()
                metrics = []
                
                for run in runs_data.get('workflow_runs', []):
                    # 計算執行時間
                    created_at = dateutil.parser.parse(run['created_at'])
                    updated_at = dateutil.parser.parse(run['updated_at'])
                    duration_seconds = (updated_at - created_at).total_seconds()
                    
                    metrics.append({
                        'workflow_name': run['name'],
                        'run_id': run['id'],
                        'status': run['conclusion'],
                        'branch': run['head_branch'],
                        'duration_seconds': duration_seconds,
                        'duration_minutes': round(duration_seconds / 60, 2),
                        'created_at': run['created_at'],
                        'updated_at': run['updated_at'],
                        'trigger_event': run['event'],
                        'attempt': run['run_attempt']
                    })
                
                return metrics
                
            except Exception as e:
                print(f"❌ 收集指標失敗: {e}")
                return None
        
        # 主邏輯
        if __name__ == '__main__':
            print("📊 開始收集 CI/CD 效能指標...")
            
            metrics = collect_workflow_metrics()
            if not metrics:
                print("⚠️ 未收集到有效數據")
                sys.exit(0)
            
            # 輸出統計摘要
            print(f"✅ 收集到 {len(metrics)} 個執行記錄")
            
            # 計算基本統計
            durations = [m['duration_minutes'] for m in metrics if m['duration_minutes'] > 0]
            if durations:
                avg_duration = sum(durations) / len(durations)
                max_duration = max(durations)
                min_duration = min(durations)
                
                print(f"📊 執行時間統計:")
                print(f"  • 平均: {avg_duration:.2f} 分鐘")
                print(f"  • 最長: {max_duration:.2f} 分鐘")  
                print(f"  • 最短: {min_duration:.2f} 分鐘")
                
                # 設置 GitHub Actions 輸出
                print(f"has_data=true", file=open(os.environ['GITHUB_OUTPUT'], 'a'))
                print(f"execution_time={avg_duration:.2f}", file=open(os.environ['GITHUB_OUTPUT'], 'a'))
                
                # 識別最常執行的 workflow
                workflow_counts = {}
                for m in metrics:
                    name = m['workflow_name']
                    workflow_counts[name] = workflow_counts.get(name, 0) + 1
                
                most_common = max(workflow_counts.items(), key=lambda x: x[1])
                print(f"workflow_name={most_common[0]}", file=open(os.environ['GITHUB_OUTPUT'], 'a'))
                
                # 保存詳細數據供後續分析
                with open('metrics_data.json', 'w') as f:
                    json.dump(metrics, f, indent=2)
                
                print("💾 指標數據已保存到 metrics_data.json")
            else:
                print("⚠️ 無有效執行時間數據")
        EOF
        
        python collect_metrics.py

    - name: 📤 上傳指標數據
      if: steps.collect.outputs.has_data == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: performance-metrics-${{ github.run_id }}
        path: |
          metrics_data.json
        retention-days: 30

  analyze-bottlenecks:
    name: 🔍 瓶頸分析
    needs: collect-metrics
    runs-on: ubuntu-latest
    if: needs.collect-metrics.outputs.has_data == 'true'
    timeout-minutes: 15

    steps:
    - name: 📥 檢出代碼
      uses: actions/checkout@v4

    - name: 🐍 設置 Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
        cache: 'pip'

    - name: 📦 安裝分析依賴
      run: |
        pip install matplotlib seaborn pandas numpy requests

    - name: 📥 下載指標數據
      uses: actions/download-artifact@v4
      with:
        name: performance-metrics-${{ github.run_id }}

    - name: 🔍 執行瓶頸分析
      run: |
        cat << 'EOF' > analyze_bottlenecks.py
        import json
        import pandas as pd
        import matplotlib.pyplot as plt
        import seaborn as sns
        from datetime import datetime
        import numpy as np
        
        def analyze_performance_bottlenecks():
            """分析 CI/CD 效能瓶頸"""
            
            # 載入數據
            try:
                with open('metrics_data.json', 'r') as f:
                    metrics = json.load(f)
            except FileNotFoundError:
                print("❌ 找不到指標數據文件")
                return
            
            if not metrics:
                print("❌ 沒有可分析的數據")
                return
                
            df = pd.DataFrame(metrics)
            
            print("🔍 CI/CD 效能瓶頸分析報告")
            print("=" * 50)
            
            # 1. 按 workflow 分析平均執行時間
            print("\n📊 各 Workflow 平均執行時間:")
            workflow_stats = df.groupby('workflow_name')['duration_minutes'].agg(['mean', 'median', 'max', 'count'])
            workflow_stats = workflow_stats.sort_values('mean', ascending=False)
            
            for name, stats in workflow_stats.iterrows():
                print(f"• {name}:")
                print(f"  - 平均: {stats['mean']:.2f} 分鐘")
                print(f"  - 中位數: {stats['median']:.2f} 分鐘")
                print(f"  - 最長: {stats['max']:.2f} 分鐘") 
                print(f"  - 執行次數: {stats['count']}")
            
            # 2. 識別效能瓶頸 (前 3 大耗時 workflows)
            print("\n🚨 效能瓶頸 TOP 3:")
            top_bottlenecks = workflow_stats.head(3)
            bottleneck_list = []
            
            for i, (name, stats) in enumerate(top_bottlenecks.iterrows(), 1):
                print(f"{i}. {name}: 平均 {stats['mean']:.2f} 分鐘")
                bottleneck_list.append({
                    'rank': i,
                    'workflow': name,
                    'avg_duration': stats['mean'],
                    'improvement_potential': max(0, stats['mean'] - 5.0)  # 目標是 5 分鐘內
                })
            
            # 3. 成功率分析
            print("\n✅ 成功率分析:")
            success_rate = df.groupby('workflow_name')['status'].apply(
                lambda x: (x == 'success').sum() / len(x) * 100
            ).sort_values(ascending=False)
            
            for name, rate in success_rate.items():
                status = "✅" if rate >= 95 else "⚠️" if rate >= 90 else "❌"
                print(f"{status} {name}: {rate:.1f}% 成功率")
            
            # 4. 趨勢分析 (最近 10 次執行)
            print("\n📈 最近趨勢分析:")
            recent_df = df.head(10)
            recent_avg = recent_df['duration_minutes'].mean()
            overall_avg = df['duration_minutes'].mean()
            trend = "📈 上升" if recent_avg > overall_avg else "📉 下降"
            
            print(f"• 最近 10 次平均: {recent_avg:.2f} 分鐘")
            print(f"• 整體平均: {overall_avg:.2f} 分鐘")
            print(f"• 趨勢: {trend} ({recent_avg - overall_avg:+.2f} 分鐘)")
            
            # 5. 優化建議
            print("\n💡 優化建議:")
            total_potential_savings = sum(b['improvement_potential'] for b in bottleneck_list)
            
            print(f"1. 優化前 3 大瓶頸，預估可節省 {total_potential_savings:.1f} 分鐘")
            print("2. 實作智能跳過機制，針對小變更避免完整測試")
            print("3. 改善快取策略，提高依賴安裝效率")
            
            if success_rate.min() < 95:
                failing_workflows = success_rate[success_rate < 95].index.tolist()
                print(f"4. 改善失敗率較高的 workflows: {', '.join(failing_workflows)}")
            
            # 生成簡單的報告摘要
            with open('performance_analysis.md', 'w') as f:
                f.write("# CI/CD 效能分析報告\n\n")
                f.write(f"**分析時間**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write(f"**數據範圍**: 最近 {len(df)} 次執行\n\n")
                
                f.write("## 📊 關鍵指標\n")
                f.write(f"- 平均執行時間: {overall_avg:.2f} 分鐘\n")
                f.write(f"- 整體成功率: {(df['status'] == 'success').sum() / len(df) * 100:.1f}%\n")
                f.write(f"- 最長執行時間: {df['duration_minutes'].max():.2f} 分鐘\n\n")
                
                f.write("## 🚨 主要瓶頸\n")
                for b in bottleneck_list:
                    f.write(f"{b['rank']}. {b['workflow']}: {b['avg_duration']:.2f} 分鐘\n")
                
                f.write(f"\n## 💰 優化潛力\n")
                f.write(f"預估可節省執行時間: {total_potential_savings:.1f} 分鐘\n")
                f.write(f"目標執行時間: < 8 分鐘\n")
        
        if __name__ == '__main__':
            analyze_performance_bottlenecks()
        EOF
        
        python analyze_bottlenecks.py

    - name: 📤 上傳分析報告
      uses: actions/upload-artifact@v4
      with:
        name: performance-analysis-${{ github.run_id }}
        path: |
          performance_analysis.md
        retention-days: 30

  generate-summary:
    name: 📋 生成效能摘要
    needs: [collect-metrics, analyze-bottlenecks]
    runs-on: ubuntu-latest
    if: always() && needs.collect-metrics.outputs.has_data == 'true'
    timeout-minutes: 5

    steps:
    - name: 📥 下載分析結果
      uses: actions/download-artifact@v4
      with:
        name: performance-analysis-${{ github.run_id }}

    - name: 📊 生成效能摘要
      run: |
        echo "## 🚀 CI/CD 效能監控報告" > performance_summary.md
        echo "" >> performance_summary.md
        echo "**監控時間**: $(date '+%Y-%m-%d %H:%M:%S UTC')" >> performance_summary.md
        echo "**平均執行時間**: ${{ needs.collect-metrics.outputs.execution_time }} 分鐘" >> performance_summary.md
        echo "**主要 Workflow**: ${{ needs.collect-metrics.outputs.workflow_name }}" >> performance_summary.md
        echo "" >> performance_summary.md
        
        if [ -f "performance_analysis.md" ]; then
          echo "### 詳細分析" >> performance_summary.md
          cat performance_analysis.md >> performance_summary.md
        fi
        
        echo "" >> performance_summary.md
        echo "---" >> performance_summary.md
        echo "*自動生成於: $(date)*" >> performance_summary.md

    - name: 📤 上傳最終報告
      uses: actions/upload-artifact@v4  
      with:
        name: ci-cd-performance-report
        path: |
          performance_summary.md
          performance_analysis.md
        retention-days: 90

    - name: 📊 輸出效能摘要
      run: |
        echo "🎯 CI/CD 效能監控完成!"
        echo ""
        echo "📊 關鍵指標:"
        echo "• 平均執行時間: ${{ needs.collect-metrics.outputs.execution_time }} 分鐘"
        echo "• 監控數據: 已收集並分析"
        echo "• 瓶頸識別: 已完成"
        echo ""
        echo "📋 後續行動:"
        echo "1. 查看詳細分析報告 (Artifacts)"
        echo "2. 根據瓶頸分析實施優化"
        echo "3. 建立效能基準追蹤"
        echo ""
        echo "🔗 相關文件:"
        echo "• 效能分析報告: performance_analysis.md"
        echo "• 原始數據: metrics_data.json"